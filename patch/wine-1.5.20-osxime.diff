文件 wine-1.5.20-ori/.DS_Store 和 wine-1.5.20/.DS_Store 不同
diff -urN wine-1.5.20-ori/configure wine-1.5.20/configure
--- wine-1.5.20-ori/configure	2012-12-22 03:14:42.000000000 +0800
+++ wine-1.5.20/configure	2012-12-28 15:17:56.000000000 +0800
@@ -686,8 +686,11 @@
 SECURITYLIB
 DISKARBITRATIONLIB
 LDEXECFLAGS
+OBJC_OBJS
+OBJC_SRCS
 CORESERVICESLIB
 APPLICATIONSERVICESLIB
+APPKITLIB
 IOKITLIB
 COREFOUNDATIONLIB
 DLLWRAP
@@ -6556,15 +6559,22 @@
     LDDLLFLAGS="-bundle -multiply_defined suppress"
     LIBWINE_LDFLAGS="-multiply_defined suppress"
     LDSHARED="\$(CC) -dynamiclib"
+        INSTALL="/usr/bin/env STRIPPROG=\\\"strip -x\\\" \\\$(top_srcdir)/tools/install-sh -c"
     LDRPATH_LOCAL="&& install_name_tool -change @executable_path/\`\$(RELPATH) \$(bindir) \$(libdir)\`/libwine.1.dylib @executable_path/\$(top_builddir)/libs/wine/libwine.1.dylib \$@ || \$(RM) \$@"
         COREFOUNDATIONLIB="-framework CoreFoundation"
 
     IOKITLIB="-framework IOKit -framework CoreFoundation"
 
+    APPKITLIB="-framework AppKit"
+
     APPLICATIONSERVICESLIB="-framework ApplicationServices"
 
     CORESERVICESLIB="-framework CoreServices"
 
+    OBJC_SRCS="\$(OBJC_SRCS)"
+
+    OBJC_OBJS="\$(OBJC_SRCS:.m=.o)"
+
     case $host_os in
       darwin11*)
         LDEXECFLAGS="-image_base 0x7bf00000 -Wl,-macosx_version_min,10.6,-segaddr,WINE_DOS,0x00001000,-segaddr,WINE_SHAREDHEAP,0x7f000000"
@@ -6673,6 +6683,7 @@
     then
         CARBONLIB="-framework Carbon"
 
+        enable_wineosxime_drv=${enable_wineosxime_drv:-yes}
     fi
 
         if test "$ac_cv_header_ApplicationServices_ApplicationServices_h" = "yes"
@@ -7142,6 +7153,7 @@
 
 enable_wineqtdecoder=${enable_wineqtdecoder:-no}
 enable_winemac_drv=${enable_winemac_drv:-no}
+enable_wineosxime_drv=${enable_wineosxime_drv:-no}
 
 if test "$LIBEXT" = "a"; then
   as_fn_error $? "could not find a way to build shared libraries.
@@ -15894,6 +15906,7 @@
 wine_fn_config_dll winemapi enable_winemapi
 wine_fn_config_dll winemp3.acm enable_winemp3_acm
 wine_fn_config_dll wineoss.drv enable_wineoss_drv
+wine_fn_config_dll wineosxime.drv enable_wineosxime_drv
 wine_fn_config_dll wineps.drv enable_wineps_drv install-lib,po
 wine_fn_config_dll wineps16.drv16 enable_win16
 wine_fn_config_dll wineqtdecoder enable_wineqtdecoder
diff -urN wine-1.5.20-ori/configure.ac wine-1.5.20/configure.ac
--- wine-1.5.20-ori/configure.ac	2012-12-22 03:14:42.000000000 +0800
+++ wine-1.5.20/configure.ac	2012-12-28 14:12:33.000000000 +0800
@@ -724,12 +724,17 @@
     LDDLLFLAGS="-bundle -multiply_defined suppress"
     LIBWINE_LDFLAGS="-multiply_defined suppress"
     LDSHARED="\$(CC) -dynamiclib"
+    dnl Work around Apple's broken strip
+    INSTALL="/usr/bin/env STRIPPROG=\\\"strip -x\\\" \\\$(top_srcdir)/tools/install-sh -c"
     LDRPATH_LOCAL="&& install_name_tool -change @executable_path/\`\$(RELPATH) \$(bindir) \$(libdir)\`/libwine.1.dylib @executable_path/\$(top_builddir)/libs/wine/libwine.1.dylib \$@ || \$(RM) \$@"
     dnl declare needed frameworks
     AC_SUBST(COREFOUNDATIONLIB,"-framework CoreFoundation")
     AC_SUBST(IOKITLIB,"-framework IOKit -framework CoreFoundation")
+    AC_SUBST(APPKITLIB,"-framework AppKit")
     AC_SUBST(APPLICATIONSERVICESLIB,"-framework ApplicationServices")
     AC_SUBST(CORESERVICESLIB,"-framework CoreServices")
+    AC_SUBST(OBJC_SRCS,"\$(OBJC_SRCS)")
+    AC_SUBST(OBJC_OBJS,"\$(OBJC_SRCS:.m=.o)")
     case $host_os in
       darwin11*)
         AC_SUBST(LDEXECFLAGS,["-image_base 0x7bf00000 -Wl,-macosx_version_min,10.6,-segaddr,WINE_DOS,0x00001000,-segaddr,WINE_SHAREDHEAP,0x7f000000"]) ;;
@@ -799,6 +804,7 @@
     if test "$ac_cv_header_Carbon_Carbon_h" = "yes"
     then
         AC_SUBST(CARBONLIB,"-framework Carbon")
+        enable_wineosxime_drv=${enable_wineosxime_drv:-yes}
     fi
 
     dnl Enable Mac driver on Mac OS X 10.6 or later
@@ -908,6 +914,7 @@
 
 enable_wineqtdecoder=${enable_wineqtdecoder:-no}
 enable_winemac_drv=${enable_winemac_drv:-no}
+enable_wineosxime_drv=${enable_wineosxime_drv:-no}
 
 if test "$LIBEXT" = "a"; then
   AC_MSG_ERROR(
@@ -3069,6 +3076,7 @@
 WINE_CONFIG_DLL(winemapi)
 WINE_CONFIG_DLL(winemp3.acm)
 WINE_CONFIG_DLL(wineoss.drv)
+WINE_CONFIG_DLL(wineosxime.drv)
 WINE_CONFIG_DLL(wineps.drv,,[install-lib,po])
 WINE_CONFIG_DLL(wineps16.drv16,enable_win16)
 WINE_CONFIG_DLL(wineqtdecoder)
diff -urN wine-1.5.20-ori/dlls/user32/message.c wine-1.5.20/dlls/user32/message.c
--- wine-1.5.20-ori/dlls/user32/message.c	2012-12-22 03:14:42.000000000 +0800
+++ wine-1.5.20/dlls/user32/message.c	2012-12-28 15:08:40.000000000 +0800
@@ -2453,7 +2453,11 @@
     }
     accept_hardware_message( hw_id, remove, 0 );
 
+#ifdef __APPLE__
+    if ( msg->message == WM_KEYDOWN || msg->message == WM_KEYUP || msg->message == WM_SYSKEYDOWN  || msg->message == WM_SYSKEYUP)
+#else
     if ( msg->message == WM_KEYDOWN || msg->message == WM_KEYUP )
+#endif
         if ( ImmProcessKey(msg->hwnd, GetKeyboardLayout(0), msg->wParam, msg->lParam, 0) )
             msg->wParam = VK_PROCESSKEY;
 
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/ime.c wine-1.5.20/dlls/wineosxime.drv/ime.c
--- wine-1.5.20-ori/dlls/wineosxime.drv/ime.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/ime.c	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,1615 @@
+/*
+ * The IME for interfacing with Apple OS X
+ *
+ * Copyright 2008 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/*
+ * Notes:
+ *  The normal flow for IMM/IME Processing is as follows.
+ * 1) The Keyboard Driver generates key messages which are first passed to
+ *    the IMM and then to IME via ImeProcessKey. If the IME returns 0  then
+ *    it does not want the key and the keyboard driver then generates the
+ *    WM_KEYUP/WM_KEYDOWN messages.  However if the IME is going to process the
+ *    key it returns non-zero.
+ * 2) If the IME is going to process the key then the IMM calls ImeToAsciiEx to
+ *    process the key.  the IME modifies the HIMC structure to reflect the
+ *    current state and generates any messages it needs the IMM to process.
+ * 3) IMM checks the messages and send them to the application in question. From
+ *    here the IMM level deals with if the application is IME aware or not.
+ */
+
+#ifdef __APPLE__
+#include "config.h"
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "wine/debug.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "winnls.h"
+#include "osxime_private.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mac_ime);
+
+extern TSMHandle gHandle;
+
+#define FROM_X11 ((HIMC)0xcafe1337)
+
+typedef struct _IMEPRIVATE {
+    BOOL bInComposition;
+    BOOL bInternalState;
+    HFONT textfont;
+    HWND hwndDefault;
+
+    LONG xKeySym;
+    LONG xKeyCode;
+
+    WCHAR unichar;
+
+    DWORD compositionFlags;
+} IMEPRIVATE, *LPIMEPRIVATE;
+
+typedef struct _tagTRANSMSG {
+    UINT message;
+    WPARAM wParam;
+    LPARAM lParam;
+} TRANSMSG, *LPTRANSMSG;
+
+static const WCHAR UI_CLASS_NAME[] = {'W','i','n','e','O','S',' ','X','I','M','E',0};
+
+static HIMC *hSelectedFrom = NULL;
+static INT  hSelectedCount = 0;
+
+/* MSIME messages */
+static UINT WM_MSIME_SERVICE;
+static UINT WM_MSIME_RECONVERTOPTIONS;
+static UINT WM_MSIME_MOUSE;
+static UINT WM_MSIME_RECONVERTREQUEST;
+static UINT WM_MSIME_RECONVERT;
+static UINT WM_MSIME_QUERYPOSITION;
+static UINT WM_MSIME_DOCUMENTFEED;
+
+static LRESULT WINAPI IME_WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
+                                          LPARAM lParam);
+static void UpdateDataInDefaultIMEWindow(HIMC hHIMC, HWND hwnd, BOOL showable);
+
+static HIMC RealIMC(HIMC hIMC)
+{
+    if (hIMC == FROM_X11)
+    {
+        INT i;
+        HWND wnd = GetFocus();
+        HIMC winHimc = ImmGetContext(wnd);
+        for (i = 0; i < hSelectedCount; i++)
+            if (winHimc == hSelectedFrom[i])
+                return winHimc;
+        return NULL;
+    }
+    else
+        return hIMC;
+}
+
+static LPINPUTCONTEXT LockRealIMC(HIMC hIMC)
+{
+    HIMC real_imc = RealIMC(hIMC);
+    if (real_imc)
+        return (LPINPUTCONTEXT)ImmLockIMC(real_imc);
+    else
+        return NULL;
+}
+
+static BOOL UnlockRealIMC(HIMC hIMC)
+{
+    HIMC real_imc = RealIMC(hIMC);
+    if (real_imc)
+        return ImmUnlockIMC(real_imc);
+    else
+        return FALSE;
+}
+
+static HIMCC ImeCreateBlankCompStr(void)
+{
+    HIMCC rc;
+    LPCOMPOSITIONSTRING ptr;
+    rc = ImmCreateIMCC(sizeof(COMPOSITIONSTRING));
+    ptr = (LPCOMPOSITIONSTRING)ImmLockIMCC(rc);
+    memset(ptr,0,sizeof(COMPOSITIONSTRING));
+    ptr->dwSize = sizeof(COMPOSITIONSTRING);
+    ImmUnlockIMCC(rc);
+    return rc;
+}
+
+static int updateField(DWORD origLen, DWORD origOffset, DWORD currentOffset,
+                       LPBYTE target, LPBYTE source, DWORD* lenParam,
+                       DWORD* offsetParam, BOOL wchars )
+{
+     if (origLen > 0 && origOffset > 0)
+     {
+        int truelen = origLen;
+        if (wchars)
+            truelen *= sizeof(WCHAR);
+
+        memcpy(&target[currentOffset], &source[origOffset], truelen);
+
+        *lenParam = origLen;
+        *offsetParam = currentOffset;
+        currentOffset += truelen;
+     }
+     return currentOffset;
+}
+
+static HIMCC updateCompStr(HIMCC old, LPWSTR compstr, DWORD len, DWORD *flags)
+{
+    /* we need to make sure the CompStr, CompClaus and CompAttr fields are all
+     * set and correct */
+    int needed_size;
+    HIMCC   rc;
+    LPBYTE newdata = NULL;
+    LPBYTE olddata = NULL;
+    LPCOMPOSITIONSTRING new_one;
+    LPCOMPOSITIONSTRING lpcs = NULL;
+    INT current_offset = 0;
+
+    TRACE("%s, %i\n",debugstr_wn(compstr,len),len);
+
+    if (old == NULL && compstr == NULL && len == 0)
+        return NULL;
+
+    if (old != NULL)
+    {
+        olddata = ImmLockIMCC(old);
+        lpcs = (LPCOMPOSITIONSTRING)olddata;
+    }
+
+    needed_size = sizeof(COMPOSITIONSTRING) + len * sizeof(WCHAR) +
+                  len + sizeof(DWORD) * 2;
+
+    if (lpcs != NULL)
+    {
+        needed_size += lpcs->dwCompReadAttrLen;
+        needed_size += lpcs->dwCompReadClauseLen;
+        needed_size += lpcs->dwCompReadStrLen * sizeof(DWORD);
+        needed_size += lpcs->dwResultReadClauseLen;
+        needed_size += lpcs->dwResultReadStrLen * sizeof(DWORD);
+        needed_size += lpcs->dwResultClauseLen;
+        needed_size += lpcs->dwResultStrLen * sizeof(DWORD);
+        needed_size += lpcs->dwPrivateSize;
+    }
+    rc = ImmCreateIMCC(needed_size);
+    newdata = ImmLockIMCC(rc);
+    new_one = (LPCOMPOSITIONSTRING)newdata;
+
+    new_one->dwSize = needed_size;
+    current_offset = sizeof(COMPOSITIONSTRING);
+    if (lpcs != NULL)
+    {
+        current_offset = updateField(lpcs->dwCompReadAttrLen,
+                                     lpcs->dwCompReadAttrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadAttrLen,
+                                     &new_one->dwCompReadAttrOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadClauseLen,
+                                     lpcs->dwCompReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadClauseLen,
+                                     &new_one->dwCompReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadStrLen,
+                                     lpcs->dwCompReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadStrLen,
+                                     &new_one->dwCompReadStrOffset, TRUE);
+
+        /* new CompAttr, CompClause, CompStr, dwCursorPos */
+        new_one->dwDeltaStart = 0;
+        new_one->dwCursorPos = lpcs->dwCursorPos;
+
+        current_offset = updateField(lpcs->dwResultReadClauseLen,
+                                     lpcs->dwResultReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadClauseLen,
+                                     &new_one->dwResultReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwResultReadStrLen,
+                                     lpcs->dwResultReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadStrLen,
+                                     &new_one->dwResultReadStrOffset, TRUE);
+
+        current_offset = updateField(lpcs->dwResultClauseLen,
+                                     lpcs->dwResultClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultClauseLen,
+                                     &new_one->dwResultClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwResultStrLen,
+                                     lpcs->dwResultStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultStrLen,
+                                     &new_one->dwResultStrOffset, TRUE);
+
+        current_offset = updateField(lpcs->dwPrivateSize,
+                                     lpcs->dwPrivateOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwPrivateSize,
+                                     &new_one->dwPrivateOffset, FALSE);
+    }
+    else
+    {
+        new_one->dwCursorPos = len;
+        *flags |= GCS_CURSORPOS;
+    }
+
+    /* set new data */
+    /* CompAttr */
+    new_one->dwCompAttrLen = len;
+    if (len > 0)
+    {
+        new_one->dwCompAttrOffset = current_offset;
+        memset(&newdata[current_offset],ATTR_INPUT,len);
+        current_offset += len;
+    }
+
+    /* CompClause */
+    if (len > 0)
+    {
+        new_one->dwCompClauseLen = sizeof(DWORD) * 2;
+        new_one->dwCompClauseOffset = current_offset;
+        *(DWORD*)(&newdata[current_offset]) = 0;
+        current_offset += sizeof(DWORD);
+        *(DWORD*)(&newdata[current_offset]) = len;
+        current_offset += sizeof(DWORD);
+    }
+
+    /* CompStr */
+    new_one->dwCompStrLen = len;
+    if (len > 0)
+    {
+        new_one->dwCompStrOffset = current_offset;
+        memcpy(&newdata[current_offset],compstr,len*sizeof(WCHAR));
+    }
+
+
+    ImmUnlockIMCC(rc);
+    if (lpcs)
+        ImmUnlockIMCC(old);
+
+    return rc;
+}
+
+static HIMCC updateResultStr(HIMCC old, LPWSTR resultstr, DWORD len)
+{
+    /* we need to make sure the ResultStr and ResultClause fields are all
+     * set and correct */
+    int needed_size;
+    HIMCC   rc;
+    LPBYTE newdata = NULL;
+    LPBYTE olddata = NULL;
+    LPCOMPOSITIONSTRING new_one;
+    LPCOMPOSITIONSTRING lpcs = NULL;
+    INT current_offset = 0;
+
+    TRACE("%s, %i\n",debugstr_wn(resultstr,len),len);
+
+    if (old == NULL && resultstr == NULL && len == 0)
+        return NULL;
+
+    if (old != NULL)
+    {
+        olddata = ImmLockIMCC(old);
+        lpcs = (LPCOMPOSITIONSTRING)olddata;
+    }
+
+    needed_size = sizeof(COMPOSITIONSTRING) + len * sizeof(WCHAR) +
+                  sizeof(DWORD) * 2;
+
+    if (lpcs != NULL)
+    {
+        needed_size += lpcs->dwCompReadAttrLen;
+        needed_size += lpcs->dwCompReadClauseLen;
+        needed_size += lpcs->dwCompReadStrLen * sizeof(DWORD);
+        needed_size += lpcs->dwCompAttrLen;
+        needed_size += lpcs->dwCompClauseLen;
+        needed_size += lpcs->dwCompStrLen * sizeof(DWORD);
+        needed_size += lpcs->dwResultReadClauseLen;
+        needed_size += lpcs->dwResultReadStrLen * sizeof(DWORD);
+        needed_size += lpcs->dwPrivateSize;
+    }
+    rc = ImmCreateIMCC(needed_size);
+    newdata = ImmLockIMCC(rc);
+    new_one = (LPCOMPOSITIONSTRING)newdata;
+
+    new_one->dwSize = needed_size;
+    current_offset = sizeof(COMPOSITIONSTRING);
+    if (lpcs != NULL)
+    {
+        current_offset = updateField(lpcs->dwCompReadAttrLen,
+                                     lpcs->dwCompReadAttrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadAttrLen,
+                                     &new_one->dwCompReadAttrOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadClauseLen,
+                                     lpcs->dwCompReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadClauseLen,
+                                     &new_one->dwCompReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompReadStrLen,
+                                     lpcs->dwCompReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompReadStrLen,
+                                     &new_one->dwCompReadStrOffset, TRUE);
+
+        current_offset = updateField(lpcs->dwCompAttrLen,
+                                     lpcs->dwCompAttrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompAttrLen,
+                                     &new_one->dwCompAttrOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompClauseLen,
+                                     lpcs->dwCompClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompClauseLen,
+                                     &new_one->dwCompClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwCompStrLen,
+                                     lpcs->dwCompStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwCompStrLen,
+                                     &new_one->dwCompStrOffset, TRUE);
+
+        new_one->dwCursorPos = lpcs->dwCursorPos;
+        new_one->dwDeltaStart = 0;
+
+        current_offset = updateField(lpcs->dwResultReadClauseLen,
+                                     lpcs->dwResultReadClauseOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadClauseLen,
+                                     &new_one->dwResultReadClauseOffset, FALSE);
+
+        current_offset = updateField(lpcs->dwResultReadStrLen,
+                                     lpcs->dwResultReadStrOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwResultReadStrLen,
+                                     &new_one->dwResultReadStrOffset, TRUE);
+
+        /* new ResultClause , ResultStr */
+
+        current_offset = updateField(lpcs->dwPrivateSize,
+                                     lpcs->dwPrivateOffset,
+                                     current_offset, newdata, olddata,
+                                     &new_one->dwPrivateSize,
+                                     &new_one->dwPrivateOffset, FALSE);
+    }
+
+    /* set new data */
+    /* ResultClause */
+    if (len > 0)
+    {
+        new_one->dwResultClauseLen = sizeof(DWORD) * 2;
+        new_one->dwResultClauseOffset = current_offset;
+        *(DWORD*)(&newdata[current_offset]) = 0;
+        current_offset += sizeof(DWORD);
+        *(DWORD*)(&newdata[current_offset]) = len;
+        current_offset += sizeof(DWORD);
+    }
+
+    /* ResultStr */
+    new_one->dwResultStrLen = len;
+    if (len > 0)
+    {
+        new_one->dwResultStrOffset = current_offset;
+        memcpy(&newdata[current_offset],resultstr,len*sizeof(WCHAR));
+    }
+    ImmUnlockIMCC(rc);
+    if (lpcs)
+        ImmUnlockIMCC(old);
+
+    return rc;
+}
+
+static void GenerateIMEMessage(HIMC hIMC, UINT msg, WPARAM wParam,
+                               LPARAM lParam)
+{
+    LPINPUTCONTEXT lpIMC;
+    LPTRANSMSG lpTransMsg;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    lpIMC->hMsgBuf = ImmReSizeIMCC(lpIMC->hMsgBuf, (lpIMC->dwNumMsgBuf + 1) *
+                                    sizeof(TRANSMSG));
+    if (!lpIMC->hMsgBuf)
+        return;
+
+    lpTransMsg = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
+    if (!lpTransMsg)
+        return;
+
+    lpTransMsg += lpIMC->dwNumMsgBuf;
+    lpTransMsg->message = msg;
+    lpTransMsg->wParam = wParam;
+    lpTransMsg->lParam = lParam;
+
+    ImmUnlockIMCC(lpIMC->hMsgBuf);
+    lpIMC->dwNumMsgBuf++;
+
+    ImmGenerateMessage(RealIMC(hIMC));
+    UnlockRealIMC(hIMC);
+}
+
+static void GenerateIMECHARMessages(HIMC hIMC, LPWSTR String, DWORD length)
+{
+    LPINPUTCONTEXT lpIMC;
+    LPTRANSMSG lpTransMsg;
+    INT i;
+
+    if (length <= 0)
+        return;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    lpIMC->hMsgBuf = ImmReSizeIMCC(lpIMC->hMsgBuf,
+                                  (lpIMC->dwNumMsgBuf + length) *
+                                    sizeof(TRANSMSG));
+    if (!lpIMC->hMsgBuf)
+        return;
+
+    lpTransMsg = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
+    if (!lpTransMsg)
+        return;
+
+    lpTransMsg += lpIMC->dwNumMsgBuf;
+    for (i = 0; i < length; i++)
+    {
+        lpTransMsg->message = WM_IME_CHAR;
+        lpTransMsg->wParam = String[i];
+        lpTransMsg->lParam = 1;
+        lpTransMsg ++;
+    }
+
+    ImmUnlockIMCC(lpIMC->hMsgBuf);
+    lpIMC->dwNumMsgBuf+=length;
+
+    ImmGenerateMessage(RealIMC(hIMC));
+    UnlockRealIMC(hIMC);
+}
+
+static BOOL GenerateMessageToTransKey( LPDWORD lpTransBuf, UINT *uNumTranMsgs,
+                                       UINT msg, WPARAM wParam, LPARAM lParam)
+{
+    LPTRANSMSG ptr;
+
+    if ((*uNumTranMsgs) +1 >= (UINT)*lpTransBuf)
+        return FALSE;
+
+    ptr = (LPTRANSMSG)(lpTransBuf+1+(*uNumTranMsgs)*3);
+    ptr->message = msg;
+    ptr->wParam = wParam;
+    ptr->lParam = lParam;
+    (*uNumTranMsgs)++;
+
+    return TRUE;
+}
+
+
+static BOOL IME_RemoveFromSelected(HIMC hIMC)
+{
+    int i;
+    for (i = 0; i < hSelectedCount; i++)
+        if (hSelectedFrom[i] == hIMC)
+        {
+            if (i < hSelectedCount - 1)
+                memcpy(&hSelectedFrom[i], &hSelectedFrom[i+1], (hSelectedCount - i - 1)*sizeof(HIMC));
+            hSelectedCount --;
+            return TRUE;
+        }
+    return FALSE;
+}
+
+static void IME_AddToSelected(HIMC hIMC)
+{
+    hSelectedCount++;
+    if (hSelectedFrom)
+        hSelectedFrom = HeapReAlloc(GetProcessHeap(), 0, hSelectedFrom, hSelectedCount*sizeof(HIMC));
+    else
+        hSelectedFrom = HeapAlloc(GetProcessHeap(), 0, sizeof(HIMC));
+    hSelectedFrom[hSelectedCount-1] = hIMC;
+}
+
+BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass,
+                       LPCWSTR lpszOption)
+{
+    TRACE("\n");
+    lpIMEInfo->dwPrivateDataSize = sizeof (IMEPRIVATE);
+    lpIMEInfo->fdwProperty = IME_PROP_UNICODE | IME_PROP_AT_CARET;
+    lpIMEInfo->fdwConversionCaps = IME_CMODE_NATIVE;
+    lpIMEInfo->fdwSentenceCaps = IME_SMODE_AUTOMATIC;
+    lpIMEInfo->fdwUICaps = UI_CAP_2700;
+    /* Tell App we cannot accept ImeSetCompositionString calls */
+    lpIMEInfo->fdwSCSCaps = 0;
+    lpIMEInfo->fdwSelectCaps = SELECT_CAP_CONVERSION;
+
+    lstrcpyW(lpszUIClass,UI_CLASS_NAME);
+
+    return TRUE;
+}
+
+BOOL WINAPI ImeConfigure(HKL hKL,HWND hWnd, DWORD dwMode, LPVOID lpData)
+{
+    FIXME("(%p, %p, %d, %p): stub\n", hKL, hWnd, dwMode, lpData);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+DWORD WINAPI ImeConversionList(HIMC hIMC, LPCWSTR lpSource,
+                LPCANDIDATELIST lpCandList, DWORD dwBufLen, UINT uFlag)
+
+{
+    FIXME("(%p, %s, %p, %d, %d): stub\n", hIMC, debugstr_w(lpSource),
+                                          lpCandList, dwBufLen, uFlag);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+BOOL WINAPI ImeDestroy(UINT uForce)
+{
+    TRACE("\n");
+    HeapFree(GetProcessHeap(),0,hSelectedFrom);
+    hSelectedFrom = NULL;
+    hSelectedCount = 0;
+    return TRUE;
+}
+
+LRESULT WINAPI ImeEscape(HIMC hIMC, UINT uSubFunc, LPVOID lpData)
+{
+    TRACE("%x %p\n",uSubFunc, lpData);
+    switch (uSubFunc)
+    {
+        case IME_ESC_QUERY_SUPPORT:
+        {
+            DWORD *dwEsc = (DWORD*)lpData;
+            if ((*dwEsc == IME_ESC_PRIVATE_FIRST + 0x10) ||
+                (*dwEsc == IME_ESC_PRIVATE_FIRST + 0x11))
+                return 1;
+        }
+        case IME_ESC_PRIVATE_FIRST + 0x10: /* X keysym */
+        {
+            LPINPUTCONTEXT lpIMC;
+            lpIMC = LockRealIMC(hIMC);
+            if (lpIMC)
+            {
+                LPIMEPRIVATE myPrivate;
+                myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                myPrivate->xKeySym = (LONG)lpData;
+                ImmUnlockIMCC(lpIMC->hPrivate);
+            }
+            UnlockRealIMC(hIMC);
+            break;
+        }
+        case IME_ESC_PRIVATE_FIRST + 0x11: /* X keycode */
+        {
+            LPINPUTCONTEXT lpIMC;
+            lpIMC = LockRealIMC(hIMC);
+            if (lpIMC)
+            {
+                LPIMEPRIVATE myPrivate;
+                myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                myPrivate->xKeyCode = (LONG)lpData;
+                ImmUnlockIMCC(lpIMC->hPrivate);
+            }
+            UnlockRealIMC(hIMC);
+            break;
+        }
+        case IME_ESC_PRIVATE_FIRST + 0x12: /* Mac unichar */
+        {
+            LPINPUTCONTEXT lpIMC;
+            lpIMC = LockRealIMC(hIMC);
+            if (lpIMC)
+            {
+                LPIMEPRIVATE myPrivate;
+                myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                myPrivate->unichar = (WCHAR)lpData;
+                ImmUnlockIMCC(lpIMC->hPrivate);
+            }
+            UnlockRealIMC(hIMC);
+            break;
+        }
+    }
+    return 0;
+}
+
+BOOL WINAPI ImeProcessKey(HIMC hIMC, UINT vKey, LPARAM lKeyData,
+                             CONST LPBYTE lpbKeyState)
+{
+    LPINPUTCONTEXT lpIMC;
+    BOOL inIME;
+
+    if (!gHandle)
+        return FALSE;
+
+    TRACE("%x 0x%lx %p\n",vKey, lKeyData, lpbKeyState);
+
+    switch (vKey)
+    {
+        case VK_SHIFT:
+        case VK_CONTROL:
+        case VK_CAPITAL:
+        case VK_MENU:
+        return FALSE;
+    }
+
+    if ((vKey == VK_KANA) || (vKey == VK_KANJI) ||
+        (vKey == VK_SPACE && lpbKeyState[VK_MENU] & 0x80 ))
+    {
+        TRACE("Mode Switch\n");
+        return TRUE;
+    }
+
+    inIME = Server_MacTSMCheckModeAndIME();
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC)
+    {
+        LPIMEPRIVATE myPrivate;
+        myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+
+        if (inIME && !myPrivate->bInternalState)
+        {
+            ImmSetOpenStatus(RealIMC(FROM_X11), TRUE);
+        }
+        else if (!inIME && myPrivate->bInternalState)
+        {
+            ShowWindow(myPrivate->hwndDefault, SW_HIDE);
+            ImmDestroyIMCC(lpIMC->hCompStr);
+            lpIMC->hCompStr = ImeCreateBlankCompStr();
+            ImmSetOpenStatus(RealIMC(FROM_X11), FALSE);
+        }
+
+        myPrivate->bInternalState = inIME;
+        ImmUnlockIMCC(lpIMC->hPrivate);
+    }
+    UnlockRealIMC(hIMC);
+
+    return inIME;
+}
+
+BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect)
+{
+    LPINPUTCONTEXT lpIMC;
+    TRACE("%p %s\n",hIMC,(fSelect)?"TRUE":"FALSE");
+
+    if (hIMC == FROM_X11)
+    {
+        ERR("ImeSelect should never be called from X11\n");
+        return FALSE;
+    }
+
+    if (!hIMC)
+        return TRUE;
+
+    /* not selected */
+    if (!fSelect)
+        return IME_RemoveFromSelected(hIMC);
+
+    IME_AddToSelected(hIMC);
+
+    /* Initialize our structures */
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC != NULL)
+    {
+        LPIMEPRIVATE myPrivate;
+        myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+        myPrivate->bInComposition = FALSE;
+        myPrivate->bInternalState = FALSE;
+        myPrivate->textfont = NULL;
+        myPrivate->hwndDefault = NULL;
+        myPrivate->xKeySym = 0;
+        myPrivate->xKeyCode = 0;
+        myPrivate->unichar = 0;
+        ImmUnlockIMCC(lpIMC->hPrivate);
+        UnlockRealIMC(hIMC);
+    }
+
+    return TRUE;
+}
+
+BOOL WINAPI ImeSetActiveContext(HIMC hIMC,BOOL fFlag)
+{
+    FIXME("Stub\n");
+    return TRUE;
+}
+
+UINT WINAPI ImeToAsciiEx (UINT uVKey, UINT uScanCode,
+                          CONST LPBYTE lpbKeyState, LPDWORD lpdwTransKey,
+                          UINT fuState, HIMC hIMC)
+{
+    UINT vkey;
+    LPINPUTCONTEXT lpIMC;
+    LPIMEPRIVATE myPrivate;
+    HWND hwndDefault;
+    INT rc;
+
+    vkey = LOWORD(uVKey);
+
+    TRACE("Incomming %x %x %p\n",vkey, uScanCode,hIMC);
+
+    if ((vkey == VK_KANA) || (vkey == VK_KANJI) || (vkey == VK_MENU))
+    {
+        TRACE("Skipping metakey\n");
+        return 0;
+    }
+
+    if ((vkey == VK_KANA) || (vkey == VK_KANJI) ||
+        (vkey == VK_SPACE && lpbKeyState[VK_MENU] & 0x80 ))
+    {
+        TRACE("Mode Switch\n");
+        Server_MacTSMFixTextService();
+        Server_MacTSMRevertToPreviousMode();
+        return 0;
+    }
+
+    lpIMC = LockRealIMC(hIMC);
+    myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+    if (!myPrivate->bInternalState)
+    {
+        ImmUnlockIMCC(lpIMC->hPrivate);
+        UnlockRealIMC(hIMC);
+        return 0;
+    }
+
+    if (!myPrivate->unichar)
+    {
+        LONG keysym;
+        LONG keycode;
+
+        keysym = myPrivate->xKeySym;
+        keycode = myPrivate->xKeyCode;
+        hwndDefault = myPrivate->hwndDefault;
+        ImmUnlockIMCC(lpIMC->hPrivate);
+        UnlockRealIMC(hIMC);
+
+        TRACE("Processing X %x %x %x\n",vkey, keysym, keycode);
+        rc = Server_XToAscii(vkey,keysym,keycode,lpbKeyState,lpdwTransKey,hIMC);
+    }
+    else
+    {
+        WCHAR unichar;
+        LONG keycode;
+
+        unichar = myPrivate->unichar;
+        keycode = myPrivate->xKeyCode;
+        hwndDefault = myPrivate->hwndDefault;
+        ImmUnlockIMCC(lpIMC->hPrivate);
+        UnlockRealIMC(hIMC);
+
+        TRACE("Processing Mac %x %x %x\n",vkey, unichar, keycode);
+        rc = Server_MacToAscii(vkey,unichar,unichar,keycode,lpbKeyState,lpdwTransKey,hIMC);
+    }
+
+    if (!rc)
+    {
+        UINT msgs = 0;
+        /* KeyStroke not processed by the IME
+         * so we need to rebuild the KeyDown message and pass it on to WINE
+         */
+        if (uScanCode & 0x8000)
+        {
+            if (!GenerateMessageToTransKey(lpdwTransKey, &msgs, WM_KEYUP, vkey,
+                                      MAKELONG(0x0001,uScanCode)))
+                GenerateIMEMessage(hIMC,WM_KEYUP,vkey,MAKELONG(0x0001,uScanCode));
+        }
+        else
+        {
+            if (!GenerateMessageToTransKey(lpdwTransKey, &msgs, WM_KEYDOWN, vkey,
+                                      MAKELONG(0x0001,uScanCode)))
+                GenerateIMEMessage(hIMC,WM_KEYDOWN,vkey,MAKELONG(0x0001,uScanCode));
+        }
+        return msgs;
+    }
+    else
+        UpdateDataInDefaultIMEWindow(hIMC, hwndDefault, FALSE);
+    return 0;
+}
+
+BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
+{
+    BOOL bRet = FALSE;
+    LPINPUTCONTEXT lpIMC;
+
+    TRACE("%p %i %i %i\n",hIMC,dwAction,dwIndex,dwValue);
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return FALSE;
+
+    switch (dwAction)
+    {
+        case NI_OPENCANDIDATE: FIXME("NI_OPENCANDIDATE\n"); break;
+        case NI_CLOSECANDIDATE: FIXME("NI_CLOSECANDIDATE\n"); break;
+        case NI_SELECTCANDIDATESTR: FIXME("NI_SELECTCANDIDATESTR\n"); break;
+        case NI_CHANGECANDIDATELIST: FIXME("NI_CHANGECANDIDATELIST\n"); break;
+        case NI_SETCANDIDATE_PAGESTART: FIXME("NI_SETCANDIDATE_PAGESTART\n"); break;
+        case NI_SETCANDIDATE_PAGESIZE: FIXME("NI_SETCANDIDATE_PAGESIZE\n"); break;
+        case NI_CONTEXTUPDATED:
+            switch (dwValue)
+            {
+                case IMC_SETCOMPOSITIONWINDOW: FIXME("NI_CONTEXTUPDATED: IMC_SETCOMPOSITIONWINDOW\n"); break;
+                case IMC_SETCONVERSIONMODE: FIXME("NI_CONTEXTUPDATED: IMC_SETCONVERSIONMODE\n"); break;
+                case IMC_SETSENTENCEMODE: FIXME("NI_CONTEXTUPDATED: IMC_SETSENTENCEMODE\n"); break;
+                case IMC_SETCANDIDATEPOS: FIXME("NI_CONTEXTUPDATED: IMC_SETCANDIDATEPOS\n"); break;
+                case IMC_SETCOMPOSITIONFONT:
+                    {
+                        LPIMEPRIVATE myPrivate;
+                        TRACE("NI_CONTEXTUPDATED: IMC_SETCOMPOSITIONFONT\n");
+
+                        myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                        if (myPrivate->textfont)
+                        {
+                            DeleteObject(myPrivate->textfont);
+                            myPrivate->textfont = NULL;
+                        }
+                        myPrivate->textfont = CreateFontIndirectW(&lpIMC->lfFont.W);
+                        ImmUnlockIMCC(lpIMC->hPrivate);
+                    }
+                    break;
+                case IMC_SETOPENSTATUS:
+                {
+                    LPIMEPRIVATE myPrivate;
+                    TRACE("NI_CONTEXTUPDATED: IMC_SETOPENSTATUS\n");
+
+                    myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                    if (lpIMC->fOpen != myPrivate->bInternalState)
+                    {
+                        if(lpIMC->fOpen == FALSE)
+                        {
+                            GenerateIMEMessage(hIMC,WM_IME_ENDCOMPOSITION,0,0);
+                        }
+                        else
+                            GenerateIMEMessage(hIMC,WM_IME_STARTCOMPOSITION,0,0);
+                    }
+                    bRet = TRUE;
+                }
+                break;
+                default: FIXME("NI_CONTEXTUPDATED: Unknown\n"); break;
+            }
+            break;
+        case NI_COMPOSITIONSTR:
+            switch (dwIndex)
+            {
+                case CPS_COMPLETE:
+                {
+                    HIMCC newCompStr;
+                    DWORD cplen = 0;
+                    LPWSTR cpstr;
+                    LPCOMPOSITIONSTRING cs = NULL;
+                    LPBYTE cdata = NULL;
+                    LPIMEPRIVATE myPrivate;
+
+                    TRACE("NI_COMPOSITIONSTR: CPS_COMPLETE\n");
+
+                    /* clear existing result */
+                    newCompStr = updateResultStr(lpIMC->hCompStr, NULL, 0);
+
+                    ImmDestroyIMCC(lpIMC->hCompStr);
+                    lpIMC->hCompStr = newCompStr;
+
+                    if (lpIMC->hCompStr)
+                    {
+                        cdata = ImmLockIMCC(lpIMC->hCompStr);
+                        cs = (LPCOMPOSITIONSTRING)cdata;
+                        cplen = cs->dwCompStrLen;
+                        cpstr = (LPWSTR)&(cdata[cs->dwCompStrOffset]);
+                        ImmUnlockIMCC(lpIMC->hCompStr);
+                    }
+                    if (cplen > 0)
+                    {
+                        WCHAR param = cpstr[0];
+                        DWORD flags = GCS_COMPSTR;
+
+                        newCompStr = updateResultStr(lpIMC->hCompStr, cpstr, cplen);
+                        ImmDestroyIMCC(lpIMC->hCompStr);
+                        lpIMC->hCompStr = newCompStr;
+                        newCompStr = updateCompStr(lpIMC->hCompStr, NULL, 0, &flags);
+                        ImmDestroyIMCC(lpIMC->hCompStr);
+                        lpIMC->hCompStr = newCompStr;
+
+                        GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, 0,
+                                                  flags);
+
+                        GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, param,
+                                            GCS_RESULTSTR|GCS_RESULTCLAUSE);
+                    }
+
+                    GenerateIMEMessage(hIMC,WM_IME_ENDCOMPOSITION, 0, 0);
+
+                    myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                    myPrivate->bInComposition = FALSE;
+                    ImmUnlockIMCC(lpIMC->hPrivate);
+
+                    bRet = TRUE;
+                }
+                break;
+                case CPS_CONVERT: FIXME("NI_COMPOSITIONSTR: CPS_CONVERT\n"); break;
+                case CPS_REVERT: FIXME("NI_COMPOSITIONSTR: CPS_REVERT\n"); break;
+                case CPS_CANCEL:
+                {
+                    BOOL send;
+                    LPCOMPOSITIONSTRING lpCompStr;
+
+                    TRACE("NI_COMPOSITIONSTR: CPS_CANCEL\n");
+
+                    lpCompStr = ImmLockIMCC(lpIMC->hCompStr);
+                    send = (lpCompStr->dwCompStrLen != 0);
+                    ImmUnlockIMCC(lpIMC->hCompStr);
+
+                    if (send)
+                    {
+                        HIMCC newCompStr;
+                        DWORD flags = GCS_COMPSTR;
+                        newCompStr = updateCompStr(lpIMC->hCompStr, NULL, 0, &flags);
+                        ImmDestroyIMCC(lpIMC->hCompStr);
+                        lpIMC->hCompStr = newCompStr;
+                        GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, 0, flags);
+                    }
+                    bRet = TRUE;
+                }
+                break;
+                default: FIXME("NI_COMPOSITIONSTR: Unknown\n"); break;
+            }
+            break;
+        default: FIXME("Unknown Message\n"); break;
+    }
+
+    UnlockRealIMC(hIMC);
+    return bRet;
+}
+
+BOOL WINAPI ImeRegisterWord(LPCWSTR lpszReading, DWORD dwStyle,
+                            LPCWSTR lpszRegister)
+{
+    FIXME("(%s, %d, %s): stub\n", debugstr_w(lpszReading), dwStyle,
+                                  debugstr_w(lpszRegister));
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+BOOL WINAPI ImeUnregisterWord(LPCWSTR lpszReading, DWORD dwStyle,
+                              LPCWSTR lpszUnregister)
+{
+    FIXME("(%s, %d, %s): stub\n", debugstr_w(lpszReading), dwStyle,
+                                  debugstr_w(lpszUnregister));
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+UINT WINAPI ImeGetRegisterWordStyle(UINT nItem, LPSTYLEBUFW lpStyleBuf)
+{
+    FIXME("(%d, %p): stub\n", nItem, lpStyleBuf);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+UINT WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROCW lpfnEnumProc,
+                                LPCWSTR lpszReading, DWORD dwStyle,
+                                LPCWSTR lpszRegister, LPVOID lpData)
+{
+    FIXME("(%p, %s, %d, %s, %p): stub\n", lpfnEnumProc,
+            debugstr_w(lpszReading), dwStyle, debugstr_w(lpszRegister),
+            lpData);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPCVOID lpComp,
+                                    DWORD dwCompLen, LPCVOID lpRead,
+                                    DWORD dwReadLen)
+{
+    LPINPUTCONTEXT lpIMC;
+    DWORD flags = 0;
+    WCHAR wParam  = 0;
+    LPIMEPRIVATE myPrivate;
+
+    TRACE("(%p, %d, %p, %d, %p, %d):\n",
+         hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
+
+    /*
+    * Explanation:
+    *  this sets the composition string in the imm32.dll level
+    *  of the composition buffer. we cannot manipulate the xim level
+    *  buffer, which means that once the xim level buffer changes again
+    *  any call to this function from the application will be lost
+    */
+
+    if (lpRead && dwReadLen)
+        FIXME("Reading string unimplemented\n");
+
+    lpIMC = LockRealIMC(hIMC);
+
+    if (lpIMC == NULL)
+        return FALSE;
+
+    myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+
+    if (dwIndex == SCS_SETSTR)
+    {
+        HIMCC newCompStr;
+
+        if (!myPrivate->bInComposition)
+        {
+            GenerateIMEMessage(hIMC, WM_IME_STARTCOMPOSITION, 0, 0);
+            myPrivate->bInComposition = TRUE;
+        }
+
+        flags = GCS_COMPSTR;
+
+        if (dwCompLen && lpComp)
+        {
+            newCompStr = updateCompStr(lpIMC->hCompStr, (LPWSTR)lpComp, dwCompLen / sizeof(WCHAR), &flags);
+            ImmDestroyIMCC(lpIMC->hCompStr);
+            lpIMC->hCompStr = newCompStr;
+
+             wParam = ((const WCHAR*)lpComp)[0];
+             flags |= myPrivate->compositionFlags;
+             flags |= GCS_COMPCLAUSE | GCS_COMPATTR | GCS_DELTASTART;
+        }
+        else
+        {
+            newCompStr = updateCompStr(lpIMC->hCompStr, NULL, 0, &flags);
+            ImmDestroyIMCC(lpIMC->hCompStr);
+            lpIMC->hCompStr = newCompStr;
+        }
+    }
+
+    GenerateIMEMessage(hIMC, WM_IME_COMPOSITION, wParam, flags);
+    ImmUnlockIMCC(lpIMC->hPrivate);
+    UnlockRealIMC(hIMC);
+
+    return TRUE;
+}
+
+DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC,  DWORD dwFlags,  DWORD dwType,
+            LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu,
+            DWORD dwSize)
+{
+    FIXME("(%p, %x %x %p %p %x): stub\n", hIMC, dwFlags, dwType,
+                                lpImeParentMenu, lpImeMenu, dwSize);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return 0;
+}
+
+/* Interfaces to XIM and other parts of winex11drv */
+
+void IME_RegisterClasses(HINSTANCE hImeInst)
+{
+    WNDCLASSW wndClass;
+    ZeroMemory(&wndClass, sizeof(WNDCLASSW));
+    wndClass.style = CS_GLOBALCLASS | CS_IME | CS_HREDRAW | CS_VREDRAW;
+    wndClass.lpfnWndProc = (WNDPROC) IME_WindowProc;
+    wndClass.cbClsExtra = 0;
+    wndClass.cbWndExtra = 2 * sizeof(LONG);
+    wndClass.hInstance = hImeInst;
+    wndClass.hCursor = LoadCursorW(NULL, (LPWSTR)IDC_ARROW);
+    wndClass.hIcon = LoadIconW(NULL, (LPWSTR)IDI_APPLICATION);
+    wndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW +1);
+    wndClass.lpszMenuName   = 0;
+    wndClass.lpszClassName = UI_CLASS_NAME;
+
+    RegisterClassW(&wndClass);
+
+    WM_MSIME_SERVICE = RegisterWindowMessageA("MSIMEService");
+    WM_MSIME_RECONVERTOPTIONS = RegisterWindowMessageA("MSIMEReconvertOptions");
+    WM_MSIME_MOUSE = RegisterWindowMessageA("MSIMEMouseOperation");
+    WM_MSIME_RECONVERTREQUEST = RegisterWindowMessageA("MSIMEReconvertRequest");
+    WM_MSIME_RECONVERT = RegisterWindowMessageA("MSIMEReconvert");
+    WM_MSIME_QUERYPOSITION = RegisterWindowMessageA("MSIMEQueryPosition");
+    WM_MSIME_DOCUMENTFEED = RegisterWindowMessageA("MSIMEDocumentFeed");
+}
+
+void IME_UnregisterClasses(HINSTANCE hImeInst)
+{
+    UnregisterClassW(UI_CLASS_NAME, hImeInst);
+}
+
+LRESULT IME_SendMessageToSelectedHWND(UINT msg, WPARAM wParam, LPARAM lParam)
+{
+    LPINPUTCONTEXT lpIMC;
+    LRESULT rc = 0;
+
+    if (!hSelectedFrom)
+        return rc;
+
+    lpIMC = LockRealIMC(FROM_X11);
+    if (lpIMC)
+        rc = SendMessageW(lpIMC->hWnd,msg,wParam,lParam);
+
+    UnlockRealIMC(FROM_X11);
+    return rc;
+}
+
+INT IME_GetCursorPos()
+{
+    LPINPUTCONTEXT lpIMC;
+    INT rc = 0;
+    LPCOMPOSITIONSTRING compstr;
+
+    if (!hSelectedFrom)
+        return rc;
+
+    lpIMC = LockRealIMC(FROM_X11);
+    if (lpIMC)
+    {
+        compstr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
+        rc = compstr->dwCursorPos;
+        ImmUnlockIMCC(lpIMC->hCompStr);
+    }
+    UnlockRealIMC(FROM_X11);
+    return rc;
+}
+
+void IME_SetCursorPos(void* hIMC, DWORD pos)
+{
+    LPINPUTCONTEXT lpIMC;
+    LPCOMPOSITIONSTRING compstr;
+    LPIMEPRIVATE myPrivate;
+
+    if (!hSelectedFrom)
+        return;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (!lpIMC)
+        return;
+
+    compstr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
+    if (!compstr)
+    {
+        UnlockRealIMC(hIMC);
+        return;
+    }
+
+    compstr->dwCursorPos = pos;
+
+    myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+    myPrivate->compositionFlags |= GCS_CURSORPOS;
+    ImmUnlockIMCC(lpIMC->hPrivate);
+    ImmUnlockIMCC(lpIMC->hCompStr);
+    UnlockRealIMC(hIMC);
+    return;
+}
+
+void IME_UpdateAssociation(HWND focus)
+{
+    ImmGetContext(focus);
+
+    if (!focus || !hSelectedFrom)
+        return;
+
+    ImmAssociateContext(focus,RealIMC(FROM_X11));
+}
+
+
+void IME_SetCompositionString(void* hIMC, LPCVOID lpComp, DWORD dwCompLen)
+{
+    ImeSetCompositionString(hIMC, SCS_SETSTR, lpComp, dwCompLen, NULL, 0);
+}
+
+void IME_NotifyComplete(void* hIMC)
+{
+    NotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+}
+
+/*****
+ * Internal functions to help with IME window management
+ */
+static void PaintDefaultIMEWnd(HIMC hIMC, HWND hwnd)
+{
+    PAINTSTRUCT ps;
+    RECT rect;
+    HDC hdc;
+    LPCOMPOSITIONSTRING compstr;
+    LPBYTE compdata = NULL;
+    HMONITOR monitor;
+    MONITORINFO mon_info;
+    INT offX=0, offY=0;
+    LPINPUTCONTEXT lpIMC;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    hdc = BeginPaint(hwnd,&ps);
+
+    GetClientRect(hwnd,&rect);
+    FillRect(hdc, &rect, (HBRUSH)(COLOR_WINDOW + 1));
+
+    compdata = ImmLockIMCC(lpIMC->hCompStr);
+    compstr = (LPCOMPOSITIONSTRING)compdata;
+
+    if (compstr->dwCompStrLen && compstr->dwCompStrOffset)
+    {
+        SIZE size;
+        POINT pt;
+        HFONT oldfont = NULL;
+        LPWSTR CompString;
+        LPIMEPRIVATE myPrivate;
+
+        CompString = (LPWSTR)(compdata + compstr->dwCompStrOffset);
+        myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+
+        if (myPrivate->textfont)
+            oldfont = SelectObject(hdc,myPrivate->textfont);
+
+        ImmUnlockIMCC(lpIMC->hPrivate);
+
+        GetTextExtentPoint32W(hdc, CompString, compstr->dwCompStrLen, &size);
+        pt.x = size.cx;
+        pt.y = size.cy;
+        LPtoDP(hdc,&pt,1);
+
+        /*
+         * How this works based on tests on windows:
+         * CFS_POINT: then we start our window at the point and grow it as large
+         *    as it needs to be for the string.
+         * CFS_RECT:  we still use the ptCurrentPos as a starting point and our
+         *    window is only as large as we need for the string, but we do not
+         *    grow such that our window exceeds the given rect.  Wrapping if
+         *    needed and possible.   If our ptCurrentPos is outside of our rect
+         *    then no window is displayed.
+         * CFS_FORCE_POSITION: appears to behave just like CFS_POINT
+         *    maybe becase the default MSIME does not do any IME adjusting.
+         */
+        if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT)
+        {
+            POINT cpt = lpIMC->cfCompForm.ptCurrentPos;
+            ClientToScreen(lpIMC->hWnd,&cpt);
+            rect.left = cpt.x;
+            rect.top = cpt.y;
+            rect.right = rect.left + pt.x;
+            rect.bottom = rect.top + pt.y;
+            monitor = MonitorFromPoint(cpt, MONITOR_DEFAULTTOPRIMARY);
+        }
+        else /* CFS_DEFAULT */
+        {
+            /* Windows places the default IME window in the bottom left */
+            HWND target = lpIMC->hWnd;
+            if (!target) target = GetFocus();
+
+            GetWindowRect(target,&rect);
+            rect.top = rect.bottom;
+            rect.right = rect.left + pt.x + 20;
+            rect.bottom = rect.top + pt.y + 20;
+            offX=offY=10;
+            monitor = MonitorFromWindow(target, MONITOR_DEFAULTTOPRIMARY);
+        }
+
+        if (lpIMC->cfCompForm.dwStyle == CFS_RECT)
+        {
+            RECT client;
+            client =lpIMC->cfCompForm.rcArea;
+            MapWindowPoints( lpIMC->hWnd, 0, (POINT *)&client, 2 );
+            IntersectRect(&rect,&rect,&client);
+            /* TODO:  Wrap the input if needed */
+        }
+
+        if (lpIMC->cfCompForm.dwStyle == CFS_DEFAULT)
+        {
+            /* make sure we are on the desktop */
+            mon_info.cbSize = sizeof(mon_info);
+            GetMonitorInfoW(monitor, &mon_info);
+
+            if (rect.bottom > mon_info.rcWork.bottom)
+            {
+                int shift = rect.bottom - mon_info.rcWork.bottom;
+                rect.top -= shift;
+                rect.bottom -= shift;
+            }
+            if (rect.left < 0)
+            {
+                rect.right -= rect.left;
+                rect.left = 0;
+            }
+            if (rect.right > mon_info.rcWork.right)
+            {
+                int shift = rect.right - mon_info.rcWork.right;
+                rect.left -= shift;
+                rect.right -= shift;
+            }
+        }
+
+        SetWindowPos(hwnd, HWND_TOPMOST, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOACTIVATE);
+
+        TextOutW(hdc, offX,offY, CompString, compstr->dwCompStrLen);
+
+        if (oldfont)
+            SelectObject(hdc,oldfont);
+    }
+
+    ImmUnlockIMCC(lpIMC->hCompStr);
+
+    EndPaint(hwnd,&ps);
+    UnlockRealIMC(hIMC);
+}
+
+static void UpdateDataInDefaultIMEWindow(HIMC hIMC, HWND hwnd, BOOL showable)
+{
+    LPCOMPOSITIONSTRING compstr;
+    LPINPUTCONTEXT lpIMC;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    if (lpIMC->hCompStr)
+        compstr = ImmLockIMCC(lpIMC->hCompStr);
+    else
+        compstr = NULL;
+
+    if (compstr == NULL || compstr->dwCompStrLen == 0)
+        ShowWindow(hwnd,SW_HIDE);
+    else if (showable)
+        ShowWindow(hwnd,SW_SHOWNOACTIVATE);
+
+    RedrawWindow(hwnd,NULL,NULL,RDW_ERASENOW|RDW_INVALIDATE);
+
+    if (compstr != NULL)
+        ImmUnlockIMCC(lpIMC->hCompStr);
+
+    UnlockRealIMC(hIMC);
+}
+
+static void DefaultIMEComposition(HIMC hIMC, HWND hwnd, LPARAM lParam)
+{
+    TRACE("IME message WM_IME_COMPOSITION 0x%lx\n", lParam);
+    if (lParam & GCS_RESULTSTR)
+    {
+        LPCOMPOSITIONSTRING compstr;
+        LPBYTE compdata;
+        LPWSTR ResultStr;
+        HIMCC newCompStr;
+        LPINPUTCONTEXT lpIMC;
+
+        lpIMC = LockRealIMC(hIMC);
+        if (lpIMC == NULL)
+            return;
+
+        TRACE("Posting result as IME_CHAR\n");
+        compdata = ImmLockIMCC(lpIMC->hCompStr);
+        compstr = (LPCOMPOSITIONSTRING)compdata;
+        ResultStr = (LPWSTR)(compdata + compstr->dwResultStrOffset);
+        GenerateIMECHARMessages(hIMC, ResultStr, compstr->dwResultStrLen);
+        ImmUnlockIMCC(lpIMC->hCompStr);
+
+        /* clear the buffer */
+        newCompStr = updateResultStr(lpIMC->hCompStr, NULL, 0);
+        ImmDestroyIMCC(lpIMC->hCompStr);
+        lpIMC->hCompStr = newCompStr;
+        UnlockRealIMC(hIMC);
+    }
+    else
+         UpdateDataInDefaultIMEWindow(hIMC,hwnd,TRUE);
+}
+
+static void DefaultIMEStartComposition(HIMC hIMC, HWND hwnd )
+{
+    LPINPUTCONTEXT lpIMC;
+
+    lpIMC = LockRealIMC(hIMC);
+    if (lpIMC == NULL)
+        return;
+
+    TRACE("IME message WM_IME_STARTCOMPOSITION\n");
+    lpIMC->hWnd = GetFocus();
+    ShowWindow(hwnd,SW_SHOWNOACTIVATE);
+    UnlockRealIMC(hIMC);
+}
+
+static LRESULT ImeHandleNotify(HIMC hIMC, HWND hwnd, UINT msg, WPARAM wParam,
+                               LPARAM lParam)
+{
+    switch (wParam)
+    {
+        case IMN_OPENSTATUSWINDOW:
+            FIXME("WM_IME_NOTIFY:IMN_OPENSTATUSWINDOW\n");
+            break;
+        case IMN_CLOSESTATUSWINDOW:
+            FIXME("WM_IME_NOTIFY:IMN_CLOSESTATUSWINDOW\n");
+            break;
+        case IMN_OPENCANDIDATE:
+            FIXME("WM_IME_NOTIFY:IMN_OPENCANDIDATE\n");
+            break;
+        case IMN_CHANGECANDIDATE:
+            FIXME("WM_IME_NOTIFY:IMN_CHANGECANDIDATE\n");
+            break;
+        case IMN_CLOSECANDIDATE:
+            FIXME("WM_IME_NOTIFY:IMN_CLOSECANDIDATE\n");
+            break;
+        case IMN_SETCONVERSIONMODE:
+            FIXME("WM_IME_NOTIFY:IMN_SETCONVERSIONMODE\n");
+            break;
+        case IMN_SETSENTENCEMODE:
+            FIXME("WM_IME_NOTIFY:IMN_SETSENTENCEMODE\n");
+            break;
+        case IMN_SETOPENSTATUS:
+            FIXME("WM_IME_NOTIFY:IMN_SETOPENSTATUS\n");
+            break;
+        case IMN_SETCANDIDATEPOS:
+            FIXME("WM_IME_NOTIFY:IMN_SETCANDIDATEPOS\n");
+            break;
+        case IMN_SETCOMPOSITIONFONT:
+            FIXME("WM_IME_NOTIFY:IMN_SETCOMPOSITIONFONT\n");
+            break;
+        case IMN_SETCOMPOSITIONWINDOW:
+            FIXME("WM_IME_NOTIFY:IMN_SETCOMPOSITIONWINDOW\n");
+            break;
+        case IMN_GUIDELINE:
+            FIXME("WM_IME_NOTIFY:IMN_GUIDELINE\n");
+            break;
+        case IMN_SETSTATUSWINDOWPOS:
+            FIXME("WM_IME_NOTIFY:IMN_SETSTATUSWINDOWPOS\n");
+            break;
+        default:
+            FIXME("WM_IME_NOTIFY:<Unknown 0x%lx>\n",wParam);
+            break;
+    }
+    return 0;
+}
+
+static LRESULT WINAPI IME_WindowProc(HWND hwnd, UINT msg, WPARAM wParam,
+                                          LPARAM lParam)
+{
+    LRESULT rc = 0;
+    HIMC    hIMC;
+
+    TRACE("Incoming Message 0x%x  (0x%08lx, 0x%08lx)\n", msg, wParam, lParam);
+
+    /*
+     * Each UI window contains the current Input Context.
+     * This Input Context can be obtained by calling GetWindowLong
+     * with IMMGWL_IMC when the UI window receives a WM_IME_xxx message.
+     * The UI window can refer to this Input Context and handles the
+     * messages.
+     */
+
+    hIMC = (HIMC)GetWindowLongW(hwnd,IMMGWL_IMC);
+    if (!hIMC)
+        hIMC = RealIMC(FROM_X11);
+
+    /* if we have no hIMC there are many messages we cannot process */
+    if (hIMC == NULL)
+    {
+        switch (msg) {
+        case WM_IME_STARTCOMPOSITION:
+        case WM_IME_ENDCOMPOSITION:
+        case WM_IME_COMPOSITION:
+        case WM_IME_NOTIFY:
+        case WM_IME_CONTROL:
+        case WM_IME_COMPOSITIONFULL:
+        case WM_IME_SELECT:
+        case WM_IME_CHAR:
+            return 0L;
+        default:
+            break;
+        }
+    }
+
+    switch(msg)
+    {
+        case WM_CREATE:
+        {
+            LPIMEPRIVATE myPrivate;
+            LPINPUTCONTEXT lpIMC;
+
+            SetWindowTextA(hwnd,"Wine Ime Active");
+
+            lpIMC = LockRealIMC(hIMC);
+            if (lpIMC)
+            {
+                myPrivate = (LPIMEPRIVATE)ImmLockIMCC(lpIMC->hPrivate);
+                myPrivate->hwndDefault = hwnd;
+                ImmUnlockIMCC(lpIMC->hPrivate);
+            }
+            UnlockRealIMC(hIMC);
+
+            return TRUE;
+        }
+        case WM_PAINT:
+            PaintDefaultIMEWnd(hIMC, hwnd);
+            return FALSE;
+
+        case WM_NCCREATE:
+            return TRUE;
+
+        case WM_SETFOCUS:
+            if (wParam)
+                SetFocus((HWND)wParam);
+            else
+                FIXME("Received focus, should never have focus\n");
+            break;
+        case WM_IME_COMPOSITION:
+            DefaultIMEComposition(hIMC, hwnd, lParam);
+            break;
+        case WM_IME_STARTCOMPOSITION:
+            DefaultIMEStartComposition(hIMC, hwnd);
+            break;
+        case WM_IME_ENDCOMPOSITION:
+            TRACE("IME message %s, 0x%lx, 0x%lx\n",
+                    "WM_IME_ENDCOMPOSITION", wParam, lParam);
+            ShowWindow(hwnd,SW_HIDE);
+            break;
+        case WM_IME_SELECT:
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_IME_SELECT", wParam, lParam);
+            break;
+        case WM_IME_CONTROL:
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_IME_CONTROL", wParam, lParam);
+            rc = 1;
+            break;
+        case WM_IME_NOTIFY:
+            rc = ImeHandleNotify(hIMC,hwnd,msg,wParam,lParam);
+            break;
+       default:
+            TRACE("Non-standard message 0x%x\n",msg);
+    }
+    /* check the MSIME messages */
+    if (msg == WM_MSIME_SERVICE)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_SERVICE", wParam, lParam);
+            rc = FALSE;
+    }
+    else if (msg == WM_MSIME_RECONVERTOPTIONS)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_RECONVERTOPTIONS", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_MOUSE)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_MOUSE", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_RECONVERTREQUEST)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_RECONVERTREQUEST", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_RECONVERT)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_RECONVERT", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_QUERYPOSITION)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_QUERYPOSITION", wParam, lParam);
+    }
+    else if (msg == WM_MSIME_DOCUMENTFEED)
+    {
+            TRACE("IME message %s, 0x%lx, 0x%lx\n","WM_MSIME_DOCUMENTFEED", wParam, lParam);
+    }
+    /* DefWndProc if not an IME message */
+    if (!rc && !((msg >= WM_IME_STARTCOMPOSITION && msg <= WM_IME_KEYLAST) ||
+                      (msg >= WM_IME_SETCONTEXT && msg <= WM_IME_KEYUP)))
+        rc = DefWindowProcW(hwnd,msg,wParam,lParam);
+
+    return rc;
+}
+
+#endif
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/IMKClient.h wine-1.5.20/dlls/wineosxime.drv/IMKClient.h
--- wine-1.5.20-ori/dlls/wineosxime.drv/IMKClient.h	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/IMKClient.h	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,40 @@
+#ifdef __APPLE__
+
+#include <Carbon/Carbon.h>
+
+
+typedef struct CXIMKClient* CXIMKClientRef;
+
+
+typedef void (*CXIMKClientUpdatedEdit)(CXIMKClientRef inClient, CFStringRef inString,
+        long inSelectionRangeLocation, long inSelectionRangeLength,
+        long inReplacementRangeLocation, long inReplacementRangeLength,
+        void *data);
+
+typedef void (*CXIMKClientCompletedText)(CXIMKClientRef inClient, CFStringRef inString,
+        long inReplacementRangeLocation, long inReplacementRangeLength,
+        void* data);
+
+typedef void (*CXIMKClientModeChanged)(CXIMKClientRef inClient, CFStringRef mode, void* data);
+
+
+CXIMKClientRef CXIMKClientInitialize(
+        CFStringRef inServerName,
+        CXIMKClientUpdatedEdit inUpdateEditCallback,
+        CXIMKClientCompletedText inCompletedTextCallback,
+        CXIMKClientModeChanged inModeChanged,
+        void* data);
+
+void CXIMKClientCleanup(CXIMKClientRef inClient);
+
+int CXIMKClientActivate(CXIMKClientRef inClient);
+
+void CXIMKClientDeactivate(CXIMKClientRef inClient);
+
+void CXIMKClientSetInputMode(CXIMKClientRef inClient, CFStringRef inMode);
+
+int CXIMKClientSendEvent(CXIMKClientRef inClient, EventRef inEvent);
+
+void CXIMKClientForceComplete(CXIMKClientRef inClient);
+
+#endif /* __APPLE__ */
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/IMKClient.m wine-1.5.20/dlls/wineosxime.drv/IMKClient.m
--- wine-1.5.20-ori/dlls/wineosxime.drv/IMKClient.m	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/IMKClient.m	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,345 @@
+#ifdef __APPLE__
+
+#include "wine/debug.h"
+
+#define BOOL MacBOOL
+
+#include "IMKClient.h"
+
+#import <Foundation/Foundation.h>
+
+#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_4
+    #import <InputMethodKit/IMKInputController.h>
+#else
+    @protocol IMKTextInput
+    @end
+    @protocol IMKUnicodeTextInput
+    @end
+    typedef long NSInteger;
+    typedef unsigned long NSUInteger;
+    typedef NSInteger IMKLocationToOffsetMappingMode;
+#endif
+
+#include <unistd.h>
+
+#define debugstr_ns(s) debugstr_a([(s) UTF8String])
+
+
+WINE_DEFAULT_DEBUG_CHANNEL(mac_xim);
+
+
+@interface NSObject (wine_IMKEvent)
++ (id) packageEventRef:(EventRef)eventRef;
+@end
+
+
+// This protocol has several close relatives in Leopard's
+// <InputMethodKit/IMKInputController.h> header.  The IMKStateSetting protocol
+// also describes methods implemented by the server object.  Where this protocol
+// describes the interface between a client and the input method server, the
+// IMKServerInput informal protocol describes the complementary interface
+// between the server object and the IMKInputController inside the server
+// process which provides the logic of how a specific input method behaves.  As
+// such, the semantics for IMKStateSetting and IMKServerInput help elucidate the
+// semantics of this protocol.
+@protocol IMKServerProxy
+- (void)activateServer:(id)sender;
+- (void)deactivateServer:(id)sender;
+- (void)sessionFinished:(id)sender;
+- (id)valueForTag:(unsigned long)tag client:(id)sender;
+- (void)setValue:(id)value forTag:(unsigned long)tag client:(id)sender;
+- (NSDictionary*)modes:(id)sender;
+- (id)menusDictionary:(id)sender;
+- (BOOL)handleEvent:(bycopy id)event characterIndex:(unsigned long)characterIndex edge:(unsigned long)edge client:(id)sender;
+- (void)commitComposition:(id)sender;
+- (void)hidePalettes:(id)sender;
+- (BOOL)didCommandBySelector:(SEL)aSelector client:(id)sender;
+- (void)doCommandBySelector:(SEL)aSelector commandDictionary:(NSDictionary*)infoDictionary client:(id)sender;
+- (NSUInteger)recognizedEvents:(id)sender;
+@end
+
+
+// See Leopard's <HIToolbox/IMKInputSession.h> header for documentation of
+// the protocols to which this class conforms.
+@interface MyTextInput : NSObject <IMKTextInput, IMKUnicodeTextInput>
+{
+    CXIMKClientRef client;
+    CXIMKClientUpdatedEdit updateEditCallback;
+    CXIMKClientCompletedText completedTextCallback;
+    CXIMKClientModeChanged modeChangedCallback;
+    void *data;
+}
+
+@end
+
+@implementation MyTextInput
+
+- (id) initWithClientRef:(CXIMKClientRef)inClient
+          updateCallback:(CXIMKClientUpdatedEdit)inUpdateEditCallback
+       completedCallback:(CXIMKClientCompletedText)inCompletedTextCallback
+       modeChangedCallback:(CXIMKClientModeChanged)inModeChangedCallback
+        clientData:(void*)inData
+{
+    self = [super init];
+    if (self != nil)
+    {
+        client = inClient;
+        updateEditCallback = inUpdateEditCallback;
+        completedTextCallback = inCompletedTextCallback;
+        modeChangedCallback = inModeChangedCallback;
+        data = inData;
+    }
+    return self;
+}
+
+
+- (void)insertText:(id)string replacementRange:(NSRange)replacementRange
+{
+    TRACE("%s { %d, %d }\n", debugstr_ns(string), replacementRange.length, replacementRange.location);
+
+    if ([string isKindOfClass:[NSAttributedString class]])
+        string = [string string];
+
+    if (string)
+        completedTextCallback(client, (CFStringRef)[[string copy] autorelease], replacementRange.location, replacementRange.length, data);
+}
+
+
+- (void)setMarkedText:(id)string selectionRange:(NSRange)selectionRange replacementRange:(NSRange)replacementRange
+{
+    TRACE("%s { %d, %d } { %d, %d }\n", debugstr_ns(string), selectionRange.length, selectionRange.location, replacementRange.length, replacementRange.location);
+
+    if ([string isKindOfClass:[NSAttributedString class]])
+        string = [string string];
+
+    if (string)
+        updateEditCallback(client, (CFStringRef)[[string copy] autorelease], selectionRange.location, selectionRange.length, replacementRange.location, replacementRange.length, data);
+}
+
+
+- (NSRange)selectedRange
+{
+    TRACE("\n");
+    return NSMakeRange(NSNotFound, NSNotFound);
+}
+
+
+- (NSRange)markedRange
+{
+    TRACE("\n");
+    return NSMakeRange(NSNotFound, NSNotFound);
+}
+
+
+- (NSAttributedString*)attributedSubstringFromRange:(NSRange)range
+{
+    TRACE("{ %d, %d }\n", range.length, range.location);
+    return [[[NSAttributedString alloc] init] autorelease];
+}
+
+
+- (NSInteger)length
+{
+    TRACE("\n");
+    return NSNotFound;
+}
+
+
+- (NSInteger)characterIndexForPoint:(NSPoint)point tracking:(IMKLocationToOffsetMappingMode)mappingMode inMarkedRange:(BOOL*)inMarkedRange
+{
+    TRACE("{ %f, %f } %ld %p\n", point.x, point.y, (long)mappingMode, inMarkedRange);
+    if (inMarkedRange)
+        *inMarkedRange = NO;
+    return NSNotFound;
+}
+
+
+- (NSDictionary*)attributesForCharacterIndex:(NSUInteger)index lineHeightRectangle:(NSRect*)lineRect
+{
+    TRACE("%lu %p\n", (unsigned long)index, lineRect);
+    if (lineRect)
+        *lineRect = NSMakeRect(100, 100, 1, 12);
+    return [NSDictionary dictionary];
+}
+
+
+- (NSArray*)validAttributesForMarkedText
+{
+    TRACE("\n");
+    return [NSArray array];
+}
+
+
+-(void)overrideKeyboardWithKeyboardNamed:(NSString*)keyboardUniqueName
+{
+    TRACE("%s\n", debugstr_ns(keyboardUniqueName));
+}
+
+
+-(void)selectInputMode:(NSString*)modeIdentifier
+{
+    TRACE("%s\n", debugstr_ns(modeIdentifier));
+
+    modeChangedCallback(client, (CFStringRef)[[modeIdentifier copy] autorelease], data);
+}
+
+
+-(BOOL)supportsUnicode
+{
+    TRACE("\n");
+    return TRUE;
+}
+
+
+-(NSString*)bundleIdentifier
+{
+    TRACE("\n");
+    return [NSString stringWithFormat:@"com.codeweavers.CXIMKClient.%d", getpid()];
+}
+
+
+-(CGWindowLevel)windowLevel
+{
+    TRACE("\n");
+    return kCGNormalWindowLevelKey;
+}
+
+
+-(void)insertText:(id)string
+{
+    TRACE("%s\n", debugstr_ns(string));
+
+    if ([string isKindOfClass:[NSAttributedString class]])
+        string = [string string];
+
+    if (string)
+        completedTextCallback(client, (CFStringRef)[[string copy] autorelease], NSNotFound, NSNotFound, data);
+}
+
+@end
+
+
+
+struct CXIMKClient
+{
+    MyTextInput* ti;
+    id<IMKServerProxy> im;
+};
+
+
+CXIMKClientRef CXIMKClientInitialize(
+        CFStringRef inServerName,
+        CXIMKClientUpdatedEdit inUpdateEditCallback,
+        CXIMKClientCompletedText inCompletedTextCallback,
+        CXIMKClientModeChanged inModeChangedCallback,
+        void *data)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    CXIMKClientRef client = malloc(sizeof(*client));
+    if (!client)
+        goto out;
+
+    client->ti = [[MyTextInput alloc] initWithClientRef:client
+                                         updateCallback:inUpdateEditCallback
+                                      completedCallback:inCompletedTextCallback
+                                      modeChangedCallback:inModeChangedCallback
+                                         clientData:data];
+    if (!client->ti)
+    {
+        free(client);
+        client = NULL;
+        goto out;
+    }
+
+    client->im = (id<IMKServerProxy>)[NSConnection rootProxyForConnectionWithRegisteredName:(NSString*)inServerName host:nil];
+    if (!client->im)
+    {
+        [client->ti release];
+        free(client);
+        client = NULL;
+        goto out;
+    }
+
+    [(id)client->im retain];
+    [(NSDistantObject*)client->im setProtocolForProxy:@protocol(IMKServerProxy)];
+
+out:
+    [pool release];
+    return client;
+}
+
+
+void CXIMKClientCleanup(CXIMKClientRef inClient)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    [(id)inClient->im release];
+    [inClient->ti release];
+    free(inClient);
+
+    [pool release];
+}
+
+
+int CXIMKClientActivate(CXIMKClientRef inClient)
+{
+    NSUInteger recognizedEvents;
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    [inClient->im activateServer:inClient->ti];
+    recognizedEvents = [inClient->im recognizedEvents:inClient->ti];
+
+    [pool release];
+
+    return (recognizedEvents & NX_KEYDOWNMASK) != 0;
+}
+
+
+void CXIMKClientDeactivate(CXIMKClientRef inClient)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    [inClient->im deactivateServer:inClient->ti];
+
+    [pool release];
+}
+
+
+void CXIMKClientSetInputMode(CXIMKClientRef inClient, CFStringRef inMode)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    [inClient->im setValue:(NSString*)inMode forTag:kTSMDocumentInputModePropertyTag client:inClient->ti];
+
+    [pool release];
+}
+
+int CXIMKClientSendEvent(CXIMKClientRef inClient, EventRef inEvent)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    static Class IMKEvent = Nil;
+    if (!IMKEvent)
+        IMKEvent = NSClassFromString(@"IMKEvent");
+
+    id imkEvent = [IMKEvent packageEventRef:inEvent];
+    int handled = [inClient->im handleEvent:imkEvent characterIndex:0 edge:0 client:inClient->ti];
+
+    [pool release];
+
+    return handled;
+}
+
+
+void CXIMKClientForceComplete(CXIMKClientRef inClient)
+{
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+
+    [inClient->im commitComposition:inClient->ti];
+
+    [pool release];
+}
+
+
+#endif /* __APPLE__ */
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/keysym2ucs.c wine-1.5.20/dlls/wineosxime.drv/keysym2ucs.c
--- wine-1.5.20-ori/dlls/wineosxime.drv/keysym2ucs.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/keysym2ucs.c	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,914 @@
+/* $XFree86: $
+ *
+ * IMPORTANT NOTE:  If you modify this file you MUST modify the corresponding
+ *                  copy of this file located in the x11 build tree
+ *
+ * This module converts keysym values into the corresponding ISO 10646
+ * (UCS, Unicode) values.
+ *
+ * The array keysymtab[] contains pairs of X11 keysym values for graphical
+ * characters and the corresponding Unicode value. The function
+ * keysym2ucs() maps a keysym onto a Unicode value using a binary search,
+ * therefore keysymtab[] must remain SORTED by keysym value.
+ *
+ * The keysym -> UTF-8 conversion will hopefully one day be provided
+ * by Xlib via XmbLookupString() and should ideally not have to be
+ * done in X applications. But we are not there yet.
+ *
+ * We allow to represent any UCS character in the range U-00000000 to
+ * U-00FFFFFF by a keysym value in the range 0x01000000 to 0x01ffffff.
+ * This admittedly does not cover the entire 31-bit space of UCS, but
+ * it does cover all of the characters up to U-10FFFF, which can be
+ * represented by UTF-16, and more, and it is very unlikely that higher
+ * UCS codes will ever be assigned by ISO. So to get Unicode character
+ * U+ABCD you can directly use keysym 0x0100abcd.
+ *
+ * NOTE: The comments in the table below contain the actual character
+ * encoded in UTF-8, so for viewing and editing best use an editor in
+ * UTF-8 mode.
+ *
+ * Author: Markus G. Kuhn <mkuhn@acm.org>, University of Cambridge, April 2001
+ *
+ * Special thanks to Richard Verhoeven <river@win.tue.nl> for preparing
+ * an initial draft of the mapping table.
+ *
+ * This software is in the public domain. Share and enjoy!
+ *
+ * AUTOMATICALLY GENERATED FILE, DO NOT EDIT !!! (unicode/convmap.pl)
+ */
+
+#ifdef __APPLE__
+#include "keysym2ucs.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+struct codepair {
+  unsigned short keysym;
+  unsigned short ucs;
+};
+
+const static struct codepair keysymtab[] = {
+  { 0x01a1, 0x0104 },
+  { 0x01a2, 0x02d8 },
+  { 0x01a3, 0x0141 },
+  { 0x01a5, 0x013d },
+  { 0x01a6, 0x015a },
+  { 0x01a9, 0x0160 },
+  { 0x01aa, 0x015e },
+  { 0x01ab, 0x0164 },
+  { 0x01ac, 0x0179 },
+  { 0x01ae, 0x017d },
+  { 0x01af, 0x017b },
+  { 0x01b1, 0x0105 },
+  { 0x01b2, 0x02db },
+  { 0x01b3, 0x0142 },
+  { 0x01b5, 0x013e },
+  { 0x01b6, 0x015b },
+  { 0x01b7, 0x02c7 },
+  { 0x01b9, 0x0161 },
+  { 0x01ba, 0x015f },
+  { 0x01bb, 0x0165 },
+  { 0x01bc, 0x017a },
+  { 0x01bd, 0x02dd },
+  { 0x01be, 0x017e },
+  { 0x01bf, 0x017c },
+  { 0x01c0, 0x0154 },
+  { 0x01c3, 0x0102 },
+  { 0x01c5, 0x0139 },
+  { 0x01c6, 0x0106 },
+  { 0x01c8, 0x010c },
+  { 0x01ca, 0x0118 },
+  { 0x01cc, 0x011a },
+  { 0x01cf, 0x010e },
+  { 0x01d0, 0x0110 },
+  { 0x01d1, 0x0143 },
+  { 0x01d2, 0x0147 },
+  { 0x01d5, 0x0150 },
+  { 0x01d8, 0x0158 },
+  { 0x01d9, 0x016e },
+  { 0x01db, 0x0170 },
+  { 0x01de, 0x0162 },
+  { 0x01e0, 0x0155 },
+  { 0x01e3, 0x0103 },
+  { 0x01e5, 0x013a },
+  { 0x01e6, 0x0107 },
+  { 0x01e8, 0x010d },
+  { 0x01ea, 0x0119 },
+  { 0x01ec, 0x011b },
+  { 0x01ef, 0x010f },
+  { 0x01f0, 0x0111 },
+  { 0x01f1, 0x0144 },
+  { 0x01f2, 0x0148 },
+  { 0x01f5, 0x0151 },
+  { 0x01f8, 0x0159 },
+  { 0x01f9, 0x016f },
+  { 0x01fb, 0x0171 },
+  { 0x01fe, 0x0163 },
+  { 0x01ff, 0x02d9 },
+  { 0x02a1, 0x0126 },
+  { 0x02a6, 0x0124 },
+  { 0x02a9, 0x0130 },
+  { 0x02ab, 0x011e },
+  { 0x02ac, 0x0134 },
+  { 0x02b1, 0x0127 },
+  { 0x02b6, 0x0125 },
+  { 0x02b9, 0x0131 },
+  { 0x02bb, 0x011f },
+  { 0x02bc, 0x0135 },
+  { 0x02c5, 0x010a },
+  { 0x02c6, 0x0108 },
+  { 0x02d5, 0x0120 },
+  { 0x02d8, 0x011c },
+  { 0x02dd, 0x016c },
+  { 0x02de, 0x015c },
+  { 0x02e5, 0x010b },
+  { 0x02e6, 0x0109 },
+  { 0x02f5, 0x0121 },
+  { 0x02f8, 0x011d },
+  { 0x02fd, 0x016d },
+  { 0x02fe, 0x015d },
+  { 0x03a2, 0x0138 },
+  { 0x03a3, 0x0156 },
+  { 0x03a5, 0x0128 },
+  { 0x03a6, 0x013b },
+  { 0x03aa, 0x0112 },
+  { 0x03ab, 0x0122 },
+  { 0x03ac, 0x0166 },
+  { 0x03b3, 0x0157 },
+  { 0x03b5, 0x0129 },
+  { 0x03b6, 0x013c },
+  { 0x03ba, 0x0113 },
+  { 0x03bb, 0x0123 },
+  { 0x03bc, 0x0167 },
+  { 0x03bd, 0x014a },
+  { 0x03bf, 0x014b },
+  { 0x03c0, 0x0100 },
+  { 0x03c7, 0x012e },
+  { 0x03cc, 0x0116 },
+  { 0x03cf, 0x012a },
+  { 0x03d1, 0x0145 },
+  { 0x03d2, 0x014c },
+  { 0x03d3, 0x0136 },
+  { 0x03d9, 0x0172 },
+  { 0x03dd, 0x0168 },
+  { 0x03de, 0x016a },
+  { 0x03e0, 0x0101 },
+  { 0x03e7, 0x012f },
+  { 0x03ec, 0x0117 },
+  { 0x03ef, 0x012b },
+  { 0x03f1, 0x0146 },
+  { 0x03f2, 0x014d },
+  { 0x03f3, 0x0137 },
+  { 0x03f9, 0x0173 },
+  { 0x03fd, 0x0169 },
+  { 0x03fe, 0x016b },
+  { 0x047e, 0x203e },
+  { 0x04a1, 0x3002 },
+  { 0x04a2, 0x300c },
+  { 0x04a3, 0x300d },
+  { 0x04a4, 0x3001 },
+  { 0x04a5, 0x30fb },
+  { 0x04a6, 0x30f2 },
+  { 0x04a7, 0x30a1 },
+  { 0x04a8, 0x30a3 },
+  { 0x04a9, 0x30a5 },
+  { 0x04aa, 0x30a7 },
+  { 0x04ab, 0x30a9 },
+  { 0x04ac, 0x30e3 },
+  { 0x04ad, 0x30e5 },
+  { 0x04ae, 0x30e7 },
+  { 0x04af, 0x30c3 },
+  { 0x04b0, 0x30fc },
+  { 0x04b1, 0x30a2 },
+  { 0x04b2, 0x30a4 },
+  { 0x04b3, 0x30a6 },
+  { 0x04b4, 0x30a8 },
+  { 0x04b5, 0x30aa },
+  { 0x04b6, 0x30ab },
+  { 0x04b7, 0x30ad },
+  { 0x04b8, 0x30af },
+  { 0x04b9, 0x30b1 },
+  { 0x04ba, 0x30b3 },
+  { 0x04bb, 0x30b5 },
+  { 0x04bc, 0x30b7 },
+  { 0x04bd, 0x30b9 },
+  { 0x04be, 0x30bb },
+  { 0x04bf, 0x30bd },
+  { 0x04c0, 0x30bf },
+  { 0x04c1, 0x30c1 },
+  { 0x04c2, 0x30c4 },
+  { 0x04c3, 0x30c6 },
+  { 0x04c4, 0x30c8 },
+  { 0x04c5, 0x30ca },
+  { 0x04c6, 0x30cb },
+  { 0x04c7, 0x30cc },
+  { 0x04c8, 0x30cd },
+  { 0x04c9, 0x30ce },
+  { 0x04ca, 0x30cf },
+  { 0x04cb, 0x30d2 },
+  { 0x04cc, 0x30d5 },
+  { 0x04cd, 0x30d8 },
+  { 0x04ce, 0x30db },
+  { 0x04cf, 0x30de },
+  { 0x04d0, 0x30df },
+  { 0x04d1, 0x30e0 },
+  { 0x04d2, 0x30e1 },
+  { 0x04d3, 0x30e2 },
+  { 0x04d4, 0x30e4 },
+  { 0x04d5, 0x30e6 },
+  { 0x04d6, 0x30e8 },
+  { 0x04d7, 0x30e9 },
+  { 0x04d8, 0x30ea },
+  { 0x04d9, 0x30eb },
+  { 0x04da, 0x30ec },
+  { 0x04db, 0x30ed },
+  { 0x04dc, 0x30ef },
+  { 0x04dd, 0x30f3 },
+  { 0x04de, 0x309b },
+  { 0x04df, 0x309c },
+  { 0x05ac, 0x060c },
+  { 0x05bb, 0x061b },
+  { 0x05bf, 0x061f },
+  { 0x05c1, 0x0621 },
+  { 0x05c2, 0x0622 },
+  { 0x05c3, 0x0623 },
+  { 0x05c4, 0x0624 },
+  { 0x05c5, 0x0625 },
+  { 0x05c6, 0x0626 },
+  { 0x05c7, 0x0627 },
+  { 0x05c8, 0x0628 },
+  { 0x05c9, 0x0629 },
+  { 0x05ca, 0x062a },
+  { 0x05cb, 0x062b },
+  { 0x05cc, 0x062c },
+  { 0x05cd, 0x062d },
+  { 0x05ce, 0x062e },
+  { 0x05cf, 0x062f },
+  { 0x05d0, 0x0630 },
+  { 0x05d1, 0x0631 },
+  { 0x05d2, 0x0632 },
+  { 0x05d3, 0x0633 },
+  { 0x05d4, 0x0634 },
+  { 0x05d5, 0x0635 },
+  { 0x05d6, 0x0636 },
+  { 0x05d7, 0x0637 },
+  { 0x05d8, 0x0638 },
+  { 0x05d9, 0x0639 },
+  { 0x05da, 0x063a },
+  { 0x05e0, 0x0640 },
+  { 0x05e1, 0x0641 },
+  { 0x05e2, 0x0642 },
+  { 0x05e3, 0x0643 },
+  { 0x05e4, 0x0644 },
+  { 0x05e5, 0x0645 },
+  { 0x05e6, 0x0646 },
+  { 0x05e7, 0x0647 },
+  { 0x05e8, 0x0648 },
+  { 0x05e9, 0x0649 },
+  { 0x05ea, 0x064a },
+  { 0x05eb, 0x064b },
+  { 0x05ec, 0x064c },
+  { 0x05ed, 0x064d },
+  { 0x05ee, 0x064e },
+  { 0x05ef, 0x064f },
+  { 0x05f0, 0x0650 },
+  { 0x05f1, 0x0651 },
+  { 0x05f2, 0x0652 },
+  { 0x06a1, 0x0452 },
+  { 0x06a2, 0x0453 },
+  { 0x06a3, 0x0451 },
+  { 0x06a4, 0x0454 },
+  { 0x06a5, 0x0455 },
+  { 0x06a6, 0x0456 },
+  { 0x06a7, 0x0457 },
+  { 0x06a8, 0x0458 },
+  { 0x06a9, 0x0459 },
+  { 0x06aa, 0x045a },
+  { 0x06ab, 0x045b },
+  { 0x06ac, 0x045c },
+  { 0x06ae, 0x045e },
+  { 0x06af, 0x045f },
+  { 0x06b0, 0x2116 },
+  { 0x06b1, 0x0402 },
+  { 0x06b2, 0x0403 },
+  { 0x06b3, 0x0401 },
+  { 0x06b4, 0x0404 },
+  { 0x06b5, 0x0405 },
+  { 0x06b6, 0x0406 },
+  { 0x06b7, 0x0407 },
+  { 0x06b8, 0x0408 },
+  { 0x06b9, 0x0409 },
+  { 0x06ba, 0x040a },
+  { 0x06bb, 0x040b },
+  { 0x06bc, 0x040c },
+  { 0x06be, 0x040e },
+  { 0x06bf, 0x040f },
+  { 0x06c0, 0x044e },
+  { 0x06c1, 0x0430 },
+  { 0x06c2, 0x0431 },
+  { 0x06c3, 0x0446 },
+  { 0x06c4, 0x0434 },
+  { 0x06c5, 0x0435 },
+  { 0x06c6, 0x0444 },
+  { 0x06c7, 0x0433 },
+  { 0x06c8, 0x0445 },
+  { 0x06c9, 0x0438 },
+  { 0x06ca, 0x0439 },
+  { 0x06cb, 0x043a },
+  { 0x06cc, 0x043b },
+  { 0x06cd, 0x043c },
+  { 0x06ce, 0x043d },
+  { 0x06cf, 0x043e },
+  { 0x06d0, 0x043f },
+  { 0x06d1, 0x044f },
+  { 0x06d2, 0x0440 },
+  { 0x06d3, 0x0441 },
+  { 0x06d4, 0x0442 },
+  { 0x06d5, 0x0443 },
+  { 0x06d6, 0x0436 },
+  { 0x06d7, 0x0432 },
+  { 0x06d8, 0x044c },
+  { 0x06d9, 0x044b },
+  { 0x06da, 0x0437 },
+  { 0x06db, 0x0448 },
+  { 0x06dc, 0x044d },
+  { 0x06dd, 0x0449 },
+  { 0x06de, 0x0447 },
+  { 0x06df, 0x044a },
+  { 0x06e0, 0x042e },
+  { 0x06e1, 0x0410 },
+  { 0x06e2, 0x0411 },
+  { 0x06e3, 0x0426 },
+  { 0x06e4, 0x0414 },
+  { 0x06e5, 0x0415 },
+  { 0x06e6, 0x0424 },
+  { 0x06e7, 0x0413 },
+  { 0x06e8, 0x0425 },
+  { 0x06e9, 0x0418 },
+  { 0x06ea, 0x0419 },
+  { 0x06eb, 0x041a },
+  { 0x06ec, 0x041b },
+  { 0x06ed, 0x041c },
+  { 0x06ee, 0x041d },
+  { 0x06ef, 0x041e },
+  { 0x06f0, 0x041f },
+  { 0x06f1, 0x042f },
+  { 0x06f2, 0x0420 },
+  { 0x06f3, 0x0421 },
+  { 0x06f4, 0x0422 },
+  { 0x06f5, 0x0423 },
+  { 0x06f6, 0x0416 },
+  { 0x06f7, 0x0412 },
+  { 0x06f8, 0x042c },
+  { 0x06f9, 0x042b },
+  { 0x06fa, 0x0417 },
+  { 0x06fb, 0x0428 },
+  { 0x06fc, 0x042d },
+  { 0x06fd, 0x0429 },
+  { 0x06fe, 0x0427 },
+  { 0x06ff, 0x042a },
+  { 0x07a1, 0x0386 },
+  { 0x07a2, 0x0388 },
+  { 0x07a3, 0x0389 },
+  { 0x07a4, 0x038a },
+  { 0x07a5, 0x03aa },
+  { 0x07a7, 0x038c },
+  { 0x07a8, 0x038e },
+  { 0x07a9, 0x03ab },
+  { 0x07ab, 0x038f },
+  { 0x07ae, 0x0385 },
+  { 0x07af, 0x2015 },
+  { 0x07b1, 0x03ac },
+  { 0x07b2, 0x03ad },
+  { 0x07b3, 0x03ae },
+  { 0x07b4, 0x03af },
+  { 0x07b5, 0x03ca },
+  { 0x07b6, 0x0390 },
+  { 0x07b7, 0x03cc },
+  { 0x07b8, 0x03cd },
+  { 0x07b9, 0x03cb },
+  { 0x07ba, 0x03b0 },
+  { 0x07bb, 0x03ce },
+  { 0x07c1, 0x0391 },
+  { 0x07c2, 0x0392 },
+  { 0x07c3, 0x0393 },
+  { 0x07c4, 0x0394 },
+  { 0x07c5, 0x0395 },
+  { 0x07c6, 0x0396 },
+  { 0x07c7, 0x0397 },
+  { 0x07c8, 0x0398 },
+  { 0x07c9, 0x0399 },
+  { 0x07ca, 0x039a },
+  { 0x07cb, 0x039b },
+  { 0x07cc, 0x039c },
+  { 0x07cd, 0x039d },
+  { 0x07ce, 0x039e },
+  { 0x07cf, 0x039f },
+  { 0x07d0, 0x03a0 },
+  { 0x07d1, 0x03a1 },
+  { 0x07d2, 0x03a3 },
+  { 0x07d4, 0x03a4 },
+  { 0x07d5, 0x03a5 },
+  { 0x07d6, 0x03a6 },
+  { 0x07d7, 0x03a7 },
+  { 0x07d8, 0x03a8 },
+  { 0x07d9, 0x03a9 },
+  { 0x07e1, 0x03b1 },
+  { 0x07e2, 0x03b2 },
+  { 0x07e3, 0x03b3 },
+  { 0x07e4, 0x03b4 },
+  { 0x07e5, 0x03b5 },
+  { 0x07e6, 0x03b6 },
+  { 0x07e7, 0x03b7 },
+  { 0x07e8, 0x03b8 },
+  { 0x07e9, 0x03b9 },
+  { 0x07ea, 0x03ba },
+  { 0x07eb, 0x03bb },
+  { 0x07ec, 0x03bc },
+  { 0x07ed, 0x03bd },
+  { 0x07ee, 0x03be },
+  { 0x07ef, 0x03bf },
+  { 0x07f0, 0x03c0 },
+  { 0x07f1, 0x03c1 },
+  { 0x07f2, 0x03c3 },
+  { 0x07f3, 0x03c2 },
+  { 0x07f4, 0x03c4 },
+  { 0x07f5, 0x03c5 },
+  { 0x07f6, 0x03c6 },
+  { 0x07f7, 0x03c7 },
+  { 0x07f8, 0x03c8 },
+  { 0x07f9, 0x03c9 },
+  { 0x08a1, 0x23b7 },
+  { 0x08a2, 0x250c },
+  { 0x08a3, 0x2500 },
+  { 0x08a4, 0x2320 },
+  { 0x08a5, 0x2321 },
+  { 0x08a6, 0x2502 },
+  { 0x08a7, 0x23a1 },
+  { 0x08a8, 0x23a3 },
+  { 0x08a9, 0x23a4 },
+  { 0x08aa, 0x23a6 },
+  { 0x08ab, 0x239b },
+  { 0x08ac, 0x239d },
+  { 0x08ad, 0x239e },
+  { 0x08ae, 0x23a0 },
+  { 0x08af, 0x23a8 },
+  { 0x08b0, 0x23ac },
+  { 0x08bc, 0x2264 },
+  { 0x08bd, 0x2260 },
+  { 0x08be, 0x2265 },
+  { 0x08bf, 0x222b },
+  { 0x08c0, 0x2234 },
+  { 0x08c1, 0x221d },
+  { 0x08c2, 0x221e },
+  { 0x08c5, 0x2207 },
+  { 0x08c8, 0x223c },
+  { 0x08c9, 0x2243 },
+  { 0x08cd, 0x21d4 },
+  { 0x08ce, 0x21d2 },
+  { 0x08cf, 0x2261 },
+  { 0x08d6, 0x221a },
+  { 0x08da, 0x2282 },
+  { 0x08db, 0x2283 },
+  { 0x08dc, 0x2229 },
+  { 0x08dd, 0x222a },
+  { 0x08de, 0x2227 },
+  { 0x08df, 0x2228 },
+  { 0x08ef, 0x2202 },
+  { 0x08f6, 0x0192 },
+  { 0x08fb, 0x2190 },
+  { 0x08fc, 0x2191 },
+  { 0x08fd, 0x2192 },
+  { 0x08fe, 0x2193 },
+  { 0x09e0, 0x25c6 },
+  { 0x09e1, 0x2592 },
+  { 0x09e2, 0x2409 },
+  { 0x09e3, 0x240c },
+  { 0x09e4, 0x240d },
+  { 0x09e5, 0x240a },
+  { 0x09e8, 0x2424 },
+  { 0x09e9, 0x240b },
+  { 0x09ea, 0x2518 },
+  { 0x09eb, 0x2510 },
+  { 0x09ec, 0x250c },
+  { 0x09ed, 0x2514 },
+  { 0x09ee, 0x253c },
+  { 0x09ef, 0x23ba },
+  { 0x09f0, 0x23bb },
+  { 0x09f1, 0x2500 },
+  { 0x09f2, 0x23bc },
+  { 0x09f3, 0x23bd },
+  { 0x09f4, 0x251c },
+  { 0x09f5, 0x2524 },
+  { 0x09f6, 0x2534 },
+  { 0x09f7, 0x252c },
+  { 0x09f8, 0x2502 },
+  { 0x0aa1, 0x2003 },
+  { 0x0aa2, 0x2002 },
+  { 0x0aa3, 0x2004 },
+  { 0x0aa4, 0x2005 },
+  { 0x0aa5, 0x2007 },
+  { 0x0aa6, 0x2008 },
+  { 0x0aa7, 0x2009 },
+  { 0x0aa8, 0x200a },
+  { 0x0aa9, 0x2014 },
+  { 0x0aaa, 0x2013 },
+  { 0x0aae, 0x2026 },
+  { 0x0aaf, 0x2025 },
+  { 0x0ab0, 0x2153 },
+  { 0x0ab1, 0x2154 },
+  { 0x0ab2, 0x2155 },
+  { 0x0ab3, 0x2156 },
+  { 0x0ab4, 0x2157 },
+  { 0x0ab5, 0x2158 },
+  { 0x0ab6, 0x2159 },
+  { 0x0ab7, 0x215a },
+  { 0x0ab8, 0x2105 },
+  { 0x0abb, 0x2012 },
+  { 0x0abc, 0x2329 },
+  { 0x0abe, 0x232a },
+  { 0x0ac3, 0x215b },
+  { 0x0ac4, 0x215c },
+  { 0x0ac5, 0x215d },
+  { 0x0ac6, 0x215e },
+  { 0x0ac9, 0x2122 },
+  { 0x0aca, 0x2613 },
+  { 0x0acc, 0x25c1 },
+  { 0x0acd, 0x25b7 },
+  { 0x0ace, 0x25cb },
+  { 0x0acf, 0x25af },
+  { 0x0ad0, 0x2018 },
+  { 0x0ad1, 0x2019 },
+  { 0x0ad2, 0x201c },
+  { 0x0ad3, 0x201d },
+  { 0x0ad4, 0x211e },
+  { 0x0ad6, 0x2032 },
+  { 0x0ad7, 0x2033 },
+  { 0x0ad9, 0x271d },
+  { 0x0adb, 0x25ac },
+  { 0x0adc, 0x25c0 },
+  { 0x0add, 0x25b6 },
+  { 0x0ade, 0x25cf },
+  { 0x0adf, 0x25ae },
+  { 0x0ae0, 0x25e6 },
+  { 0x0ae1, 0x25ab },
+  { 0x0ae2, 0x25ad },
+  { 0x0ae3, 0x25b3 },
+  { 0x0ae4, 0x25bd },
+  { 0x0ae5, 0x2606 },
+  { 0x0ae6, 0x2022 },
+  { 0x0ae7, 0x25aa },
+  { 0x0ae8, 0x25b2 },
+  { 0x0ae9, 0x25bc },
+  { 0x0aea, 0x261c },
+  { 0x0aeb, 0x261e },
+  { 0x0aec, 0x2663 },
+  { 0x0aed, 0x2666 },
+  { 0x0aee, 0x2665 },
+  { 0x0af0, 0x2720 },
+  { 0x0af1, 0x2020 },
+  { 0x0af2, 0x2021 },
+  { 0x0af3, 0x2713 },
+  { 0x0af4, 0x2717 },
+  { 0x0af5, 0x266f },
+  { 0x0af6, 0x266d },
+  { 0x0af7, 0x2642 },
+  { 0x0af8, 0x2640 },
+  { 0x0af9, 0x260e },
+  { 0x0afa, 0x2315 },
+  { 0x0afb, 0x2117 },
+  { 0x0afc, 0x2038 },
+  { 0x0afd, 0x201a },
+  { 0x0afe, 0x201e },
+  { 0x0ba3, 0x003c },
+  { 0x0ba6, 0x003e },
+  { 0x0ba8, 0x2228 },
+  { 0x0ba9, 0x2227 },
+  { 0x0bc0, 0x00af },
+  { 0x0bc2, 0x22a5 },
+  { 0x0bc3, 0x2229 },
+  { 0x0bc4, 0x230a },
+  { 0x0bc6, 0x005f },
+  { 0x0bca, 0x2218 },
+  { 0x0bcc, 0x2395 },
+  { 0x0bce, 0x22a4 },
+  { 0x0bcf, 0x25cb },
+  { 0x0bd3, 0x2308 },
+  { 0x0bd6, 0x222a },
+  { 0x0bd8, 0x2283 },
+  { 0x0bda, 0x2282 },
+  { 0x0bdc, 0x22a2 },
+  { 0x0bfc, 0x22a3 },
+  { 0x0cdf, 0x2017 },
+  { 0x0ce0, 0x05d0 },
+  { 0x0ce1, 0x05d1 },
+  { 0x0ce2, 0x05d2 },
+  { 0x0ce3, 0x05d3 },
+  { 0x0ce4, 0x05d4 },
+  { 0x0ce5, 0x05d5 },
+  { 0x0ce6, 0x05d6 },
+  { 0x0ce7, 0x05d7 },
+  { 0x0ce8, 0x05d8 },
+  { 0x0ce9, 0x05d9 },
+  { 0x0cea, 0x05da },
+  { 0x0ceb, 0x05db },
+  { 0x0cec, 0x05dc },
+  { 0x0ced, 0x05dd },
+  { 0x0cee, 0x05de },
+  { 0x0cef, 0x05df },
+  { 0x0cf0, 0x05e0 },
+  { 0x0cf1, 0x05e1 },
+  { 0x0cf2, 0x05e2 },
+  { 0x0cf3, 0x05e3 },
+  { 0x0cf4, 0x05e4 },
+  { 0x0cf5, 0x05e5 },
+  { 0x0cf6, 0x05e6 },
+  { 0x0cf7, 0x05e7 },
+  { 0x0cf8, 0x05e8 },
+  { 0x0cf9, 0x05e9 },
+  { 0x0cfa, 0x05ea },
+  { 0x0da1, 0x0e01 },
+  { 0x0da2, 0x0e02 },
+  { 0x0da3, 0x0e03 },
+  { 0x0da4, 0x0e04 },
+  { 0x0da5, 0x0e05 },
+  { 0x0da6, 0x0e06 },
+  { 0x0da7, 0x0e07 },
+  { 0x0da8, 0x0e08 },
+  { 0x0da9, 0x0e09 },
+  { 0x0daa, 0x0e0a },
+  { 0x0dab, 0x0e0b },
+  { 0x0dac, 0x0e0c },
+  { 0x0dad, 0x0e0d },
+  { 0x0dae, 0x0e0e },
+  { 0x0daf, 0x0e0f },
+  { 0x0db0, 0x0e10 },
+  { 0x0db1, 0x0e11 },
+  { 0x0db2, 0x0e12 },
+  { 0x0db3, 0x0e13 },
+  { 0x0db4, 0x0e14 },
+  { 0x0db5, 0x0e15 },
+  { 0x0db6, 0x0e16 },
+  { 0x0db7, 0x0e17 },
+  { 0x0db8, 0x0e18 },
+  { 0x0db9, 0x0e19 },
+  { 0x0dba, 0x0e1a },
+  { 0x0dbb, 0x0e1b },
+  { 0x0dbc, 0x0e1c },
+  { 0x0dbd, 0x0e1d },
+  { 0x0dbe, 0x0e1e },
+  { 0x0dbf, 0x0e1f },
+  { 0x0dc0, 0x0e20 },
+  { 0x0dc1, 0x0e21 },
+  { 0x0dc2, 0x0e22 },
+  { 0x0dc3, 0x0e23 },
+  { 0x0dc4, 0x0e24 },
+  { 0x0dc5, 0x0e25 },
+  { 0x0dc6, 0x0e26 },
+  { 0x0dc7, 0x0e27 },
+  { 0x0dc8, 0x0e28 },
+  { 0x0dc9, 0x0e29 },
+  { 0x0dca, 0x0e2a },
+  { 0x0dcb, 0x0e2b },
+  { 0x0dcc, 0x0e2c },
+  { 0x0dcd, 0x0e2d },
+  { 0x0dce, 0x0e2e },
+  { 0x0dcf, 0x0e2f },
+  { 0x0dd0, 0x0e30 },
+  { 0x0dd1, 0x0e31 },
+  { 0x0dd2, 0x0e32 },
+  { 0x0dd3, 0x0e33 },
+  { 0x0dd4, 0x0e34 },
+  { 0x0dd5, 0x0e35 },
+  { 0x0dd6, 0x0e36 },
+  { 0x0dd7, 0x0e37 },
+  { 0x0dd8, 0x0e38 },
+  { 0x0dd9, 0x0e39 },
+  { 0x0dda, 0x0e3a },
+  { 0x0ddf, 0x0e3f },
+  { 0x0de0, 0x0e40 },
+  { 0x0de1, 0x0e41 },
+  { 0x0de2, 0x0e42 },
+  { 0x0de3, 0x0e43 },
+  { 0x0de4, 0x0e44 },
+  { 0x0de5, 0x0e45 },
+  { 0x0de6, 0x0e46 },
+  { 0x0de7, 0x0e47 },
+  { 0x0de8, 0x0e48 },
+  { 0x0de9, 0x0e49 },
+  { 0x0dea, 0x0e4a },
+  { 0x0deb, 0x0e4b },
+  { 0x0dec, 0x0e4c },
+  { 0x0ded, 0x0e4d },
+  { 0x0df0, 0x0e50 },
+  { 0x0df1, 0x0e51 },
+  { 0x0df2, 0x0e52 },
+  { 0x0df3, 0x0e53 },
+  { 0x0df4, 0x0e54 },
+  { 0x0df5, 0x0e55 },
+  { 0x0df6, 0x0e56 },
+  { 0x0df7, 0x0e57 },
+  { 0x0df8, 0x0e58 },
+  { 0x0df9, 0x0e59 },
+  { 0x0ea1, 0x3131 },
+  { 0x0ea2, 0x3132 },
+  { 0x0ea3, 0x3133 },
+  { 0x0ea4, 0x3134 },
+  { 0x0ea5, 0x3135 },
+  { 0x0ea6, 0x3136 },
+  { 0x0ea7, 0x3137 },
+  { 0x0ea8, 0x3138 },
+  { 0x0ea9, 0x3139 },
+  { 0x0eaa, 0x313a },
+  { 0x0eab, 0x313b },
+  { 0x0eac, 0x313c },
+  { 0x0ead, 0x313d },
+  { 0x0eae, 0x313e },
+  { 0x0eaf, 0x313f },
+  { 0x0eb0, 0x3140 },
+  { 0x0eb1, 0x3141 },
+  { 0x0eb2, 0x3142 },
+  { 0x0eb3, 0x3143 },
+  { 0x0eb4, 0x3144 },
+  { 0x0eb5, 0x3145 },
+  { 0x0eb6, 0x3146 },
+  { 0x0eb7, 0x3147 },
+  { 0x0eb8, 0x3148 },
+  { 0x0eb9, 0x3149 },
+  { 0x0eba, 0x314a },
+  { 0x0ebb, 0x314b },
+  { 0x0ebc, 0x314c },
+  { 0x0ebd, 0x314d },
+  { 0x0ebe, 0x314e },
+  { 0x0ebf, 0x314f },
+  { 0x0ec0, 0x3150 },
+  { 0x0ec1, 0x3151 },
+  { 0x0ec2, 0x3152 },
+  { 0x0ec3, 0x3153 },
+  { 0x0ec4, 0x3154 },
+  { 0x0ec5, 0x3155 },
+  { 0x0ec6, 0x3156 },
+  { 0x0ec7, 0x3157 },
+  { 0x0ec8, 0x3158 },
+  { 0x0ec9, 0x3159 },
+  { 0x0eca, 0x315a },
+  { 0x0ecb, 0x315b },
+  { 0x0ecc, 0x315c },
+  { 0x0ecd, 0x315d },
+  { 0x0ece, 0x315e },
+  { 0x0ecf, 0x315f },
+  { 0x0ed0, 0x3160 },
+  { 0x0ed1, 0x3161 },
+  { 0x0ed2, 0x3162 },
+  { 0x0ed3, 0x3163 },
+  { 0x0ed4, 0x11a8 },
+  { 0x0ed5, 0x11a9 },
+  { 0x0ed6, 0x11aa },
+  { 0x0ed7, 0x11ab },
+  { 0x0ed8, 0x11ac },
+  { 0x0ed9, 0x11ad },
+  { 0x0eda, 0x11ae },
+  { 0x0edb, 0x11af },
+  { 0x0edc, 0x11b0 },
+  { 0x0edd, 0x11b1 },
+  { 0x0ede, 0x11b2 },
+  { 0x0edf, 0x11b3 },
+  { 0x0ee0, 0x11b4 },
+  { 0x0ee1, 0x11b5 },
+  { 0x0ee2, 0x11b6 },
+  { 0x0ee3, 0x11b7 },
+  { 0x0ee4, 0x11b8 },
+  { 0x0ee5, 0x11b9 },
+  { 0x0ee6, 0x11ba },
+  { 0x0ee7, 0x11bb },
+  { 0x0ee8, 0x11bc },
+  { 0x0ee9, 0x11bd },
+  { 0x0eea, 0x11be },
+  { 0x0eeb, 0x11bf },
+  { 0x0eec, 0x11c0 },
+  { 0x0eed, 0x11c1 },
+  { 0x0eee, 0x11c2 },
+  { 0x0eef, 0x316d },
+  { 0x0ef0, 0x3171 },
+  { 0x0ef1, 0x3178 },
+  { 0x0ef2, 0x317f },
+  { 0x0ef3, 0x3181 },
+  { 0x0ef4, 0x3184 },
+  { 0x0ef5, 0x3186 },
+  { 0x0ef6, 0x318d },
+  { 0x0ef7, 0x318e },
+  { 0x0ef8, 0x11eb },
+  { 0x0ef9, 0x11f0 },
+  { 0x0efa, 0x11f9 },
+  { 0x0eff, 0x20a9 },
+#if 0
+  /* FIXME: there is no keysym 0x13a4? But 0x20ac is EuroSign in both
+     keysym and Unicode */
+  { 0x13a4, 0x20ac },
+#endif
+  { 0x13bc, 0x0152 },
+  { 0x13bd, 0x0153 },
+  { 0x13be, 0x0178 },
+  { 0x20ac, 0x20ac },
+
+  /* Special function keys. */
+
+  { 0xff08, 0x0008 },			/* XK_BackSpace */
+  { 0xff09, 0x0009 },			/* XK_Tab */
+  { 0xff0a, 0x000a },			/* XK_Linefeed */
+  { 0xff0d, 0x000d },			/* XK_Return */
+  { 0xff13, 0x0013 },			/* XK_Pause */
+  { 0xff1b, 0x001b },			/* XK_Escape */
+  { 0xff50, 0x0001 },			/* XK_Home */
+  { 0xff51, 0x001c },			/* XK_Left */
+  { 0xff52, 0x001e },			/* XK_Up */
+  { 0xff53, 0x001d },			/* XK_Right */
+  { 0xff54, 0x001f },			/* XK_Down */
+  { 0xff55, 0x000b },			/* XK_Prior */
+  { 0xff56, 0x000c },			/* XK_Next */
+  { 0xff57, 0x0004 },			/* XK_End */
+  { 0xff6a, 0x0005 },			/* XK_Help */
+  { 0xffff, 0x007f },			/* XK_Delete */
+};
+
+long keysym2ucs(int keysym)
+{
+    int min = 0;
+    int max = sizeof(keysymtab) / sizeof(struct codepair) - 1;
+    int mid;
+
+    /* first check for Latin-1 characters (1:1 mapping) */
+    if ((keysym >= 0x0020 && keysym <= 0x007e) ||
+        (keysym >= 0x00a0 && keysym <= 0x00ff))
+        return keysym;
+
+    /* also check for directly encoded 24-bit UCS characters */
+    if ((keysym & 0xff000000) == 0x01000000)
+	return keysym & 0x00ffffff;
+
+    /* binary search in table */
+    while (max >= min) {
+	mid = (min + max) / 2;
+	if (keysymtab[mid].keysym < keysym)
+	    min = mid + 1;
+	else if (keysymtab[mid].keysym > keysym)
+	    max = mid - 1;
+	else {
+	    /* found it */
+	    return keysymtab[mid].ucs;
+	}
+    }
+
+    /* no matching Unicode value found */
+    return -1;
+}
+
+static int reverse_compare (const void *a, const void *b)
+{
+    const struct codepair *ca = a, *cb = b;
+
+    return ca->ucs - cb->ucs;
+}
+
+int ucs2keysym(long ucs)
+{
+    static struct codepair *reverse_keysymtab;
+
+    int min = 0;
+    int max = sizeof(keysymtab) / sizeof(struct codepair) - 1;
+    int mid;
+
+    if (reverse_keysymtab == NULL)
+    {
+	reverse_keysymtab = malloc (sizeof (keysymtab));
+	memcpy (reverse_keysymtab, keysymtab, sizeof (keysymtab));
+
+	qsort (reverse_keysymtab,
+	       sizeof (keysymtab) / sizeof (struct codepair),
+	       sizeof (struct codepair),
+	       reverse_compare);
+    }
+
+    /* first check for Latin-1 characters (1:1 mapping) */
+    if ((ucs >= 0x0020 && ucs <= 0x007e) ||
+        (ucs >= 0x00a0 && ucs <= 0x00ff))
+        return ucs;
+
+    /* binary search in table */
+    while (max >= min) {
+	mid = (min + max) / 2;
+	if (reverse_keysymtab[mid].ucs < ucs)
+	    min = mid + 1;
+	else if (reverse_keysymtab[mid].ucs > ucs)
+	    max = mid - 1;
+	else {
+	    /* found it */
+	    return reverse_keysymtab[mid].keysym;
+	}
+    }
+
+    /* finally, assume a directly encoded 24-bit UCS character */
+    return ucs | 0x01000000;
+}
+#endif
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/keysym2ucs.h wine-1.5.20/dlls/wineosxime.drv/keysym2ucs.h
--- wine-1.5.20-ori/dlls/wineosxime.drv/keysym2ucs.h	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/keysym2ucs.h	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,41 @@
+/* $XFree86: $
+ *
+ * IMPORTANT NOTE:  If you modify this file you MUST modify the corresponding
+ *                  copy of this file located in the x11 build tree
+ *
+ *
+ * This module converts keysym values into the corresponding ISO 10646
+ * (UCS, Unicode) values.
+ *
+ * The array keysymtab[] contains pairs of X11 keysym values for graphical
+ * characters and the corresponding Unicode value. The function
+ * keysym2ucs() maps a keysym onto a Unicode value using a binary search,
+ * therefore keysymtab[] must remain SORTED by keysym value.
+ *
+ * The keysym -> UTF-8 conversion will hopefully one day be provided
+ * by Xlib via XmbLookupString() and should ideally not have to be
+ * done in X applications. But we are not there yet.
+ *
+ * We allow to represent any UCS character in the range U-00000000 to
+ * U-00FFFFFF by a keysym value in the range 0x01000000 to 0x01ffffff.
+ * This admittedly does not cover the entire 31-bit space of UCS, but
+ * it does cover all of the characters up to U-10FFFF, which can be
+ * represented by UTF-16, and more, and it is very unlikely that higher
+ * UCS codes will ever be assigned by ISO. So to get Unicode character
+ * U+ABCD you can directly use keysym 0x0100abcd.
+ *
+ * Author: Markus G. Kuhn <mkuhn@acm.org>, University of Cambridge, April 2001
+ *
+ * Special thanks to Richard Verhoeven <river@win.tue.nl> for preparing
+ * an initial draft of the mapping table.
+ *
+ * This software is in the public domain. Share and enjoy!
+ */
+
+#ifndef KEYSYM2UCS_H
+#define KEYSYM2UCS_H 1
+
+extern long keysym2ucs(int keysym);
+extern int ucs2keysym(long ucs);
+
+#endif /* KEYSYM2UCS_H */
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/mactext.c wine-1.5.20/dlls/wineosxime.drv/mactext.c
--- wine-1.5.20-ori/dlls/wineosxime.drv/mactext.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/mactext.c	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,1254 @@
+/*
+ * Functions for Mac Input methods using Carbon
+ *
+ * Copyright 2006 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ * Much of this code based off of Kinput2.
+ *
+ * Copyright (c) 1990  Software Research Associates, Inc.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Software Research Associates not be
+ * used in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.  Software Research
+ * Associates makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * Author:  Makoto Ishisone, Software Research Associates, Inc., Japan
+ *
+ */
+
+/*
+ * Copyright 1998 Takanori Sonoda.
+ *
+ * Author: Takanori Sonoda, Kyushu Univ.  (tsonoda@gynob.med.kyushu-u.ac.jp)
+ */
+
+/*
+ * Copyright (c) 2004 kenichi kikuchi
+ * Author: kenichi kikuchi
+ */
+
+#ifdef __APPLE__
+
+#include "wine/debug.h"
+#include <Carbon/Carbon.h>
+#include <dlfcn.h>
+#include "IMKClient.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mac_xim);
+
+#define kUniCharReverseSolidus  0x005c
+#define kUniCharTilde           0x007e
+#define kUniCharYenSign         0x00a5
+#define kUniCharOverline        0x203e
+#define kCandWindWidth  (127 + 11 + 80 + 11)
+#define kMenuBarHeight  22
+
+enum {TYPE_COMPONENT,TYPE_SERVER};
+enum {STATE_NOT_ACTIVATED,STATE_ACTIVATED};
+
+typedef struct{
+    int type;
+    union {
+        CXIMKClientRef server;
+        ComponentInstance component;
+    } handle;
+    int state;
+    CFStringRef key;
+} MethodTarget;
+
+MethodTarget **AllMethods;
+
+typedef struct
+    {
+        char           *text;
+        int             textsize;
+        int             textmax;
+
+        TextRange      *hiliteRange;
+        int             hilitesize;
+        int             hilitemax;
+
+        int             fixsize;
+    } myAERecord;
+
+typedef struct
+    {
+        /* basic objects */
+        EventTargetRef      EventTarget;
+        TSMDocumentID       docID;
+        MethodTarget        *ts;
+
+        /* tracking Modes */
+        CFStringRef         CurrentModeString;
+        CFStringRef         OldModeString;
+        /* tiger tracking */
+        CFStringRef         CurrentScript;
+        CFStringRef         OldScript;
+        /* leopard tracking */
+        CFStringRef         CurrentBundle;
+        CFStringRef         OldBundle;
+        void*               OldTIS;
+        void*               CurrentTIS;
+
+        /* for event handling */
+        EventHandlerRef     EventHandler;
+        WindowRef           CandWind;
+        myAERecord          AERecord;
+
+        /* for the IME */
+        void*               hIMC;
+    } MacTSMInternals;
+
+typedef MacTSMInternals* TSMHandle;
+
+extern void IME_SetCompositionString(void* hIMC, char* text, long textSize);
+extern void IME_NotifyComplete(void* hIMC);
+extern void IME_SetCursorPos(void* hIMC, DWORD pos);
+
+static void UpdateCandWindow(TSMHandle internals);
+void PumpEvents(void);
+
+void MyIMKClientUpdatedEdit(CXIMKClientRef inClient, CFStringRef inString,
+        long inSelectionRangeLocation, long inSelectionRangeLength,
+        long inReplacementRangeLocation, long inReplacementRangeLength,
+        void* data)
+{
+    TSMHandle internals  = (TSMHandle)data;
+    CFIndex length = CFStringGetLength(inString);
+    UniChar *buffer = malloc(length * sizeof(UniChar));
+
+    if (internals->CandWind)
+        UpdateCandWindow(internals);
+
+    TRACE("Entered selection (Loc %li  Len %li) replacement (Loc %li Len %li)\n",inSelectionRangeLocation, inSelectionRangeLength, inReplacementRangeLocation,inReplacementRangeLength);
+
+    IME_SetCursorPos(internals->hIMC, inSelectionRangeLocation);
+    CFStringGetCharacters(inString, CFRangeMake(0, length), buffer);
+    IME_SetCompositionString(internals->hIMC, (char*)buffer ,length * sizeof (UniChar));
+}
+
+void MyIMKClientCompletedText(CXIMKClientRef inClient, CFStringRef inString,
+        long inReplacementRangeLocation, long inReplacementRangeLength,
+        void *data)
+{
+    TSMHandle internals  = (TSMHandle)data;
+    CFIndex length = CFStringGetLength(inString);
+    UniChar *buffer = malloc(length * sizeof(UniChar));
+
+    TRACE("ENTERED (Loc %li  Len %li)\n",inReplacementRangeLocation,inReplacementRangeLength);
+    if (internals->CandWind)
+        UpdateCandWindow(internals);
+
+    CFStringGetCharacters(inString, CFRangeMake(0, length), buffer);
+    IME_SetCompositionString(internals->hIMC, (char*)buffer, length * sizeof (UniChar));
+    IME_NotifyComplete(internals->hIMC);
+}
+
+void MyIMKClientModeChanged(CXIMKClientRef inClient, CFStringRef newmode, void* data)
+{
+    TSMHandle internals  = (TSMHandle)data;
+
+    if (CFStringCompare(newmode, internals->CurrentModeString,0)
+            != kCFCompareEqualTo)
+    {
+        CFRelease(internals->CurrentModeString);
+        internals->CurrentModeString = CFStringCreateCopy(NULL,newmode);
+    }
+
+    PumpEvents();
+}
+
+ScriptLanguageRecord *GetScriptRecord(CFStringRef script)
+{
+    static ScriptLanguageRecord scriptLanguageTCh = { smTradChinese, langTradChinese};
+    static ScriptLanguageRecord scriptLanguageSCh = { smSimpChinese, langSimpChinese};
+    static ScriptLanguageRecord scriptLanguageKr = { smKorean, langKorean};
+    static ScriptLanguageRecord scriptLanguageJp = { smJapanese, langJapanese};
+    static ScriptLanguageRecord scriptLanguageVt = { smVietnamese, langVietnamese};
+    static ScriptLanguageRecord scriptLanguageTa = { smTamil, langTamil};
+
+    if (CFStringCompare(script, CFSTR("smJapanese"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageJp;
+    else if (CFStringCompare(script, CFSTR("smTradChinese"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageTCh;
+    else if (CFStringCompare(script, CFSTR("smTCIM"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageTCh;
+    else if (CFStringCompare(script, CFSTR("smSimpChinese"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageSCh;
+    else if (CFStringCompare(script, CFSTR("smSCIM"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageSCh;
+    else if (CFStringCompare(script, CFSTR("smKorean"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageKr;
+    else if (CFStringCompare(script, CFSTR("smVietnamese"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageVt;
+    else if (CFStringCompare(script, CFSTR("smVietnameseSimpleTelex"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageVt;
+    else if (CFStringCompare(script, CFSTR("smTamil"), 0)
+                == kCFCompareEqualTo)
+        return &scriptLanguageTa;
+
+    return NULL;
+}
+
+static CFStringRef GetServerConnection(CFStringRef bundleid)
+{
+    CFBundleRef bund;
+    bund = CFBundleGetBundleWithIdentifier(bundleid);
+    if (bund)
+    {
+        static CFStringRef name = NULL;
+
+        name = CFBundleGetValueForInfoDictionaryKey(bund,
+                                CFSTR("InputMethodConnectionName"));
+
+        if (name)
+        {
+            if (TRACE_ON(mac_xim))
+            {
+                char ss[100];
+                CFStringGetCString(name,ss,100,kCFStringEncodingASCII);
+                TRACE("Server name is: %s\n", ss);
+            }
+            return name;
+        }
+
+        TRACE("Server name not found\n");
+        return CFSTR("none");
+    }
+
+    TRACE("Not an Application Bundle\n");
+    return CFSTR("none");
+}
+
+static MethodTarget* CreateNewMethodTarget( TSMHandle internals,
+                                      CFStringRef script,
+                                      CFStringRef bundleid)
+{
+    MethodTarget *tgt = NULL;
+    ScriptLanguageRecord *sl = NULL;
+    Component gComp = NULL;
+    OSStatus status;
+
+    sl = GetScriptRecord(script);
+    if (sl)
+        status = GetDefaultInputMethodOfClass(&gComp, sl, kKeyboardInputMethodClass);
+    else
+        status = -1;
+
+    if (status == noErr && gComp)
+    {
+        tgt = malloc(sizeof(MethodTarget));
+        tgt->type = TYPE_COMPONENT;
+        OpenTextService(internals->docID, gComp, &tgt->handle.component);
+        tgt->state = STATE_ACTIVATED;
+        if (bundleid)
+            tgt->key = CFStringCreateCopy(NULL,bundleid);
+        else
+            tgt->key = CFStringCreateCopy(NULL,script);
+        TRACE("Created New Component Instance \n");
+    }
+    else
+    {
+        CXIMKClientRef server;
+        TRACE("Attempting Leopard Application Server\n");
+
+        server = CXIMKClientInitialize( GetServerConnection(bundleid) ,
+                    &MyIMKClientUpdatedEdit, &MyIMKClientCompletedText,
+                    &MyIMKClientModeChanged, internals);
+
+        if (server)
+        {
+            tgt = malloc(sizeof(MethodTarget));
+            tgt->type = TYPE_SERVER;
+            tgt->handle.server = server;
+            tgt->state = STATE_ACTIVATED;
+            if (bundleid)
+                tgt->key = CFStringCreateCopy(NULL,bundleid);
+            else
+                tgt->key = CFStringCreateCopy(NULL,script);
+            TRACE("Created New Application Server\n");
+        }
+    }
+
+    return tgt;
+}
+
+static MethodTarget* FindCreateMethodTarget(TSMHandle internals,
+                                            CFStringRef script,
+                                            CFStringRef bundleid)
+{
+    MethodTarget *ptr = (MethodTarget *)AllMethods;
+    int i = 0;
+    CFStringRef key;
+
+    if (bundleid)
+        key = bundleid;
+    else
+        key = script;
+
+    if (ptr != NULL)
+    {
+        ptr = AllMethods[0];
+        while (ptr != NULL)
+        {
+            if (CFStringCompare(key, ptr->key, 0)
+                == kCFCompareEqualTo)
+                break;
+            i++;
+            ptr = AllMethods[i];
+        }
+    }
+
+    if (ptr)
+        return ptr;
+
+    ptr = CreateNewMethodTarget(internals, script, bundleid);
+    if (!ptr)
+        return ptr;
+
+    if (!AllMethods)
+    {
+        AllMethods = malloc(sizeof(MethodTarget*) * 2);
+        AllMethods[0] = ptr;
+        AllMethods[1] = 0;
+    }
+    else
+    {
+        AllMethods = realloc(AllMethods,sizeof(MethodTarget*) * (i + 2));
+        AllMethods[i] = ptr;
+        AllMethods[i+1] = 0;
+    }
+
+    return ptr;
+}
+
+static OSErr OpenAppropriateService(TSMHandle internals,
+                    CFStringRef script, CFStringRef bundleid, void* TISref)
+{
+    OSErr err = 1;
+
+    TRACE("\n");
+
+    if (internals->ts)
+    {
+        /* Shut down current service */
+        if (internals->ts->type == TYPE_COMPONENT)
+        {
+            DeactivateTextService(internals->ts->handle.component);
+            TerminateTextService(internals->ts->handle.component);
+        }
+        else
+            CXIMKClientDeactivate(internals->ts->handle.server);
+
+        internals->ts = NULL;
+    }
+
+    if (CFStringCompare(script, CFSTR("smRoman"), 0)
+                == kCFCompareEqualTo)
+    {
+        KeyScript(smKeyRoman);
+        err = noErr;
+    }
+    else
+        internals->ts = FindCreateMethodTarget(internals, script, bundleid);
+
+    if (internals->ts)
+    {
+        if (internals->ts->type == TYPE_COMPONENT)
+        {
+            err = InitiateTextService(internals->ts->handle.component);
+            if (err != noErr)
+                WARN("Failure to Initiate Text Service (%i)\n",err);
+            else
+            {
+                err = ActivateTextService(internals->ts->handle.component);
+                if (err != noErr)
+                {
+                    TerminateTextService(internals->ts->handle.component);
+                    WARN("Failure to Activate Text Service (%i)\n",err);
+                }
+            }
+
+            if (err != noErr)
+                internals->ts = NULL;
+        }
+        else
+        {
+            CXIMKClientActivate(internals->ts->handle.server);
+        }
+
+        if (TISref)
+        {
+            TRACE("TIS Select Source %p\n",TISref);
+            TISSelectInputSource(TISref);
+        }
+    }
+
+    return err;
+}
+
+static Boolean SetInputModeCFS(TSMHandle internals, CFStringRef mode)
+{
+    OSStatus status = noErr;
+
+    if (TRACE_ON(mac_xim))
+    {
+        char ss[100];
+        CFStringGetCString(mode,ss,100,kCFStringEncodingASCII);
+        TRACE("Attempting to set mode to: %s\n", ss);
+    }
+
+    if (!internals->ts)
+        return false;
+
+    if (internals->ts->type == TYPE_SERVER)
+        CXIMKClientSetInputMode(internals->ts->handle.server,mode);
+    else
+        status = SetTextServiceProperty(internals->ts->handle.component,
+                    kTextServiceInputModePropertyTag, (SInt32)mode);
+
+    if (status != noErr)
+    {
+        ERR("can't set input mode (%ld)\n", status);
+        return false;
+    }
+
+    return true;
+}
+
+static Boolean GetTISInputModeCFS( CFStringRef *out_mode,
+                        CFStringRef *out_bundle, CFStringRef* out_lang,
+                        void** TISref)
+{
+    CFStringRef string;
+    CFArrayRef  array;
+
+    PumpEvents();
+
+    *TISref = TISCopyCurrentKeyboardInputSource();
+    TRACE("TIS ref %p\n",*TISref);
+
+    string = TISGetInputSourceProperty(*TISref,kTISPropertyInputSourceType);
+    if (TRACE_ON(mac_xim) && string)
+    {
+        char ss[100];
+        CFStringGetCString(string,ss,100,kCFStringEncodingASCII);
+        TRACE("TIS type %s\n",ss);
+    }
+    if (CFStringCompare(string, CFSTR("TISTypeKeyboardInputMode"), 0)
+                != kCFCompareEqualTo)
+    {
+        TRACE("Not an Input mode\n");
+        return false;
+    }
+
+    string = TISGetInputSourceProperty(*TISref,kTISPropertyInputModeID);
+    if (TRACE_ON(mac_xim) && string)
+    {
+        char ss[100];
+        CFStringGetCString(string,ss,100,kCFStringEncodingASCII);
+        TRACE("TIS mode %s\n",ss);
+    }
+    *out_mode = CFStringCreateCopy(NULL,string);
+
+    string = TISGetInputSourceProperty(*TISref,kTISPropertyBundleID);
+    if (TRACE_ON(mac_xim) && string)
+    {
+        char ss[100];
+        CFStringGetCString(string,ss,100,kCFStringEncodingASCII);
+        TRACE("TIS bundleid %s\n",ss);
+    }
+    *out_bundle = CFStringCreateCopy(NULL,string);
+
+    array = TISGetInputSourceProperty(*TISref,kTISPropertyInputSourceLanguages);
+    if (array)
+    {
+        string = CFArrayGetValueAtIndex(array, 0);
+        if (TRACE_ON(mac_xim))
+        {
+            char ss[100];
+            CFStringGetCString(string,ss,100,kCFStringEncodingASCII);
+            TRACE("TIS intended language %s\n",ss);
+        }
+        *out_lang = CFStringCreateCopy(NULL,string);
+    }
+
+    return true;
+}
+
+static CFStringRef GetScriptFromBCP( CFStringRef language)
+{
+    if (CFStringCompare(language, CFSTR("ja"), 0) == kCFCompareEqualTo)
+        return CFStringCreateCopy(NULL,CFSTR("smJapanese"));
+    else if (CFStringCompare(language, CFSTR("ko"), 0) == kCFCompareEqualTo)
+        return CFStringCreateCopy(NULL,CFSTR("smKorean"));
+    else if (CFStringCompare(language, CFSTR("zh-Hans"), 0) == kCFCompareEqualTo)
+        return CFStringCreateCopy(NULL,CFSTR("smSimpChinese"));
+    else if (CFStringCompare(language, CFSTR("zh-Hant"), 0) == kCFCompareEqualTo)
+        return CFStringCreateCopy(NULL,CFSTR("smTradChinese"));
+    else if (CFStringCompare(language, CFSTR("ta"), 0) == kCFCompareEqualTo)
+        return CFStringCreateCopy(NULL,CFSTR("smTamil"));
+    else if (CFStringCompare(language, CFSTR("vi"), 0) == kCFCompareEqualTo)
+        return CFStringCreateCopy(NULL,CFSTR("smVietnamese"));
+
+    return NULL;
+}
+
+static int GetLeopardInputModeCFS( CFStringRef *out_mode,
+                                   CFStringRef *out_script,
+                                   CFStringRef *out_bundle,
+                                   void        **TISref)
+{
+    CFStringRef language = NULL;
+    int rc = 0;
+
+    rc = GetTISInputModeCFS(out_mode,out_bundle,&language,TISref);
+
+    if (rc)
+    {
+        char ss[100];
+        char *scr;
+        char *end;
+
+        if (language)
+        {
+            *out_script = GetScriptFromBCP(language);
+            CFRelease(language);
+        }
+
+        if ( *out_script==NULL || language==NULL )
+        {
+            CFStringRef script = NULL;
+
+            CFStringGetCString(*out_mode,ss,100,kCFStringEncodingASCII);
+            TRACE("aqua default input mode: %s\n", ss);
+
+            /* Determine script */
+            scr = strstr(ss,"inputmethod");
+            if (scr)
+            {
+                scr += 12;
+                end = strchr(scr,'.');
+                if (end)
+                    *end = 0;
+                *(scr-2) = 's';
+                *(scr-1) = 'm';
+                scr-=2;
+                TRACE("aqua default input script: %s\n", scr);
+                script = CFStringCreateWithCString(NULL,scr,kCFStringEncodingASCII);
+                *out_script = script;
+
+                /* check for roman input modes inside of IMEs */
+                if (CFStringCompare(script, CFSTR("smRoman"), 0)
+                    == kCFCompareEqualTo)
+                {
+                    TRACE("Found Roman\n");
+                    rc = 0;
+                }
+            }
+            else
+            {
+                ERR("Strange Mode line!\n");
+                rc = 0;
+                *out_script = CFSTR("smRoman");
+            }
+        }
+    }
+
+    return rc;
+}
+
+Boolean MacTSMRevertToPreviousMode(TSMHandle internals)
+{
+    Boolean different = false;
+    if (internals->OldBundle == NULL || internals->CurrentBundle == NULL)
+        different = (CFStringCompare(internals->OldScript,
+                       internals->CurrentScript, 0) != kCFCompareEqualTo);
+    else
+        different = (CFStringCompare(internals->OldBundle,
+                       internals->CurrentBundle, 0) != kCFCompareEqualTo);
+
+    if (different)
+    {
+        CFStringRef temp = internals->CurrentScript;
+        CFStringRef tempb = internals->CurrentBundle;
+        void*       tempt = internals->CurrentTIS;
+
+        if (TRACE_ON(mac_xim))
+        {
+            char ss[100],ss2[100];
+            CFStringGetCString(temp,ss,100,kCFStringEncodingASCII);
+            CFStringGetCString(internals->OldScript,ss2,100,kCFStringEncodingASCII);
+            TRACE("Switching from Script %s to %s\n",ss,ss2);
+            if (internals->OldBundle || tempb)
+            {
+                memset(ss,0,100);
+                memset(ss2,0,100);
+                if (tempb)
+                    CFStringGetCString(tempb,ss,100,kCFStringEncodingASCII);
+                if (internals->OldBundle)
+                CFStringGetCString(internals->OldBundle,ss2,100,kCFStringEncodingASCII);
+                TRACE("Switching from Bundle %s to %s\n",ss,ss2);
+            }
+        }
+
+        OpenAppropriateService(internals, internals->OldScript,
+                               internals->OldBundle,internals->OldTIS);
+
+        internals->CurrentScript = internals->OldScript;
+        internals->OldScript = temp;
+        internals->CurrentBundle = internals->OldBundle;
+        internals->OldBundle = tempb;
+        internals->CurrentTIS = internals->OldTIS;
+        internals->OldTIS = tempt;
+    }
+
+    if (CFStringCompare(internals->OldModeString,
+                        internals->CurrentModeString,0) != kCFCompareEqualTo)
+    {
+        CFStringRef temp = internals->CurrentModeString;
+        SetInputModeCFS(internals,internals->OldModeString);
+        internals->CurrentModeString = internals->OldModeString;
+        internals->OldModeString = temp;
+    }
+
+    return true;
+}
+
+Boolean MacTSMCheckModeAndIME(TSMHandle internals)
+{
+    Boolean inIME;
+    Boolean different = false;
+    CFStringRef mode = NULL;
+    CFStringRef script = NULL;
+    CFStringRef bundle = NULL;
+    void*       TISref = NULL;
+
+    TRACE("\n");
+
+    inIME = GetLeopardInputModeCFS(&mode, &script, &bundle, &TISref);
+
+    if (!script)
+        script = CFStringCreateCopy(NULL,CFSTR("smRoman"));
+    if (!mode)
+        mode = CFStringCreateCopy(NULL, kTextServiceInputModeRoman);
+
+    if (bundle && internals->CurrentBundle)
+        different = (CFStringCompare(bundle, internals->CurrentBundle, 0) !=
+                            kCFCompareEqualTo);
+    else
+        different = (CFStringCompare(script, internals->CurrentScript, 0) !=
+                            kCFCompareEqualTo);
+    if (different)
+    {
+        OpenAppropriateService(internals, script, bundle, TISref);
+
+        CFRelease(internals->OldScript);
+        internals->OldScript = internals->CurrentScript;
+        internals->CurrentScript = script;
+
+        if (internals->OldBundle)
+            CFRelease(internals->OldBundle);
+        internals->OldBundle = internals->CurrentBundle;
+        internals->CurrentBundle = bundle;
+
+        internals->OldTIS = internals->CurrentTIS;
+        internals->CurrentTIS = TISref;
+    }
+    else
+        CFRelease(script);
+
+    if (CFStringCompare(mode, internals->CurrentModeString,0)
+            != kCFCompareEqualTo)
+        SetInputModeCFS(internals, mode);
+
+    CFRelease(internals->OldModeString);
+    internals->OldModeString = internals->CurrentModeString;
+    internals->CurrentModeString = mode;
+
+    return inIME;
+}
+
+
+Boolean MacTSMEventCFS(TSMHandle internals, char theChar, unsigned long theCode,
+              unsigned long modifiers, unsigned long unichar, void* hIMC)
+{
+    OSStatus status;
+    EventRef event = NULL;
+    Boolean result;
+    UInt32 Keyboard = LMGetKbdType();
+
+    TRACE("(%02x'%c':%02lx:%04lx)\n",
+            (unsigned char)theChar, isprint(theChar) ? theChar : '.',
+            (long)theCode, (long)modifiers);
+
+    if (!internals->ts)
+        return false;
+
+    status = CreateEvent(NULL, kEventClassKeyboard, kEventRawKeyDown, 0,
+                        kEventAttributeUserEvent, &event);
+
+    if (status == noErr)
+        status = SetEventParameter(event, kEventParamKeyMacCharCodes,
+                                typeChar, sizeof(char), &theChar);
+
+    if (status == noErr)
+        status = SetEventParameter(event, kEventParamKeyCode, typeUInt32,
+                                    sizeof(UInt32), &theCode);
+
+    if (status == noErr)
+        status = SetEventParameter(event, kEventParamKeyModifiers, typeUInt32,
+                                    sizeof(UInt32), &modifiers);
+
+    if (status == noErr)
+        status = SetEventParameter(event, kEventParamKeyboardType, typeUInt32,
+                                 sizeof(UInt32), &Keyboard);
+
+    if (status == noErr && unichar != 0xffffffff)
+        status = SetEventParameter(event, kEventParamKeyUnicodes,
+                                 typeUnicodeText, sizeof(UniChar), &unichar);
+
+    internals->hIMC = hIMC;
+
+    if (status == noErr)
+    {
+        if (internals->ts->type == TYPE_SERVER)
+            status = CXIMKClientSendEvent(internals->ts->handle.server,event);
+        else
+            status = TextServiceEventRef(internals->ts->handle.component,event);
+
+        TRACE("Handled? %li\n",status);
+        if (status > 0)
+            result = true;
+        else
+            result = false;
+    }
+    else
+    {
+        ERR("can't send key to tsm (%ld)\n", status);
+        result = false;
+    }
+
+    if (event)
+        ReleaseEvent(event);
+
+    if (result)
+        while (CFRunLoopRunInMode(kCFRunLoopDefaultMode,0.0001,true)
+                ==kCFRunLoopRunHandledSource);
+
+    return result;
+}
+
+TSMHandle MacInitTSMAwareApplication(void)
+{
+    TSMHandle internals;
+
+    internals = (TSMHandle)malloc(sizeof(MacTSMInternals));
+    memset(internals,0,sizeof(MacTSMInternals));
+
+    internals->EventTarget = GetApplicationEventTarget();
+    memset(&(internals->AERecord),0,sizeof(myAERecord));
+
+    /* Initialize Modes */
+    internals->CurrentModeString = CFStringCreateCopy(NULL,
+                                        kTextServiceInputModeRoman);
+    internals->OldModeString = CFStringCreateCopy(NULL,
+                                        kTextServiceInputModeRoman);
+    internals->CurrentScript= CFStringCreateCopy(NULL,CFSTR("smRoman"));
+    internals->OldScript= CFStringCreateCopy(NULL,CFSTR("smRoman"));
+    internals->CurrentBundle= NULL;
+    internals->OldBundle= NULL;
+    internals->OldTIS = NULL;
+    internals->CurrentTIS = NULL;
+
+    InstallStandardEventHandler(GetApplicationEventTarget());
+
+    return internals;
+}
+
+void MacCloseTSMAwareApplication(TSMHandle internals)
+{
+    MethodTarget *ptr;
+    TRACE("\n");
+
+    CFRelease(internals->CurrentModeString);
+    CFRelease(internals->OldModeString);
+    CFRelease(internals->CurrentScript);
+    CFRelease(internals->OldScript);
+    if (internals->CurrentBundle)
+        CFRelease(internals->CurrentBundle);
+    if (internals->OldBundle)
+        CFRelease(internals->OldBundle);
+
+    /* clean out the myAERecord */
+    if (internals->AERecord.hiliteRange)
+        free(internals->AERecord.hiliteRange);
+    if (internals->AERecord.text)
+        free(internals->AERecord.text);
+
+    /* Cleanup all the servers and such */
+    if (AllMethods)
+    {
+        int i = 0;
+        ptr = AllMethods[0];
+        while (ptr)
+        {
+            if (ptr->type == TYPE_SERVER && ptr->state == STATE_ACTIVATED)
+                CXIMKClientCleanup(ptr->handle.server);
+            i++;
+            ptr = AllMethods[i];
+        }
+    }
+
+    free(internals);
+}
+
+
+OSErr MacNewTSMDocument(TSMHandle internals, long refcon)
+{
+    OSErr err = noErr;
+    InterfaceTypeList typeList;
+    TRACE("\n");
+
+    typeList[0] = kUnicodeDocumentInterfaceType;
+    err = NewTSMDocument(1, typeList, &(internals->docID), refcon);
+    TRACE("(%lx)\n", (long)(internals->docID));
+
+    if (err != noErr)
+    {
+        ERR("can't create tsm doc (%d)\n", err);
+        return err;
+    }
+    return noErr;
+}
+
+OSErr MacDeleteTSMDocument(TSMHandle internals)
+{
+    OSErr err = noErr;
+
+    TRACE("\n");
+
+    if (internals->ts && internals->ts->type == TYPE_COMPONENT)
+    {
+        DeactivateTextService(internals->ts->handle.component);
+        TerminateTextService(internals->ts->handle.component);
+    }
+
+    return err;
+}
+
+OSErr MacTSMFixTextService(TSMHandle internals)
+{
+    OSErr err = noErr;
+
+    if (!internals->ts)
+        return noErr;
+
+    if (internals->ts->type == TYPE_COMPONENT)
+        err = FixTextService(internals->ts->handle.component);
+    else
+        CXIMKClientForceComplete(internals->ts->handle.server);
+
+    return err;
+}
+
+OSErr MacActivateTSMDocument(TSMHandle internals)
+{
+    OSErr err = tsmComponentNoErr;
+    TRACE("Checking Active\n");
+
+    if (TSMGetActiveDocument() != internals->docID)
+        err = ActivateTSMDocument(internals->docID);
+
+    return err;
+}
+
+
+/**************************************
+ * Event Handler Logic
+ **************************************/
+static unsigned long getText(EventRef event,myAERecord *theRec)
+{
+    unsigned long   ret;
+    char           *theText = NULL;
+    OSStatus        myErr;
+    EventParamType  textType;
+
+    textType = typeUnicodeText;
+    myErr = GetEventParameter(event, kEventParamTextInputSendText, textType,
+            NULL, 0, &ret, NULL);
+    if (myErr != noErr)
+        ret = 0;
+    theRec->textsize = ret;
+
+    if (ret != 0)
+    {
+        if (ret >= theRec->textmax)
+        {
+            free(theRec->text);
+            theRec->text = (char *) malloc(sizeof(char) *
+                     (theRec->textmax + 256));
+            theRec->textmax += 256;
+        }
+
+        theText = theRec->text;
+
+        myErr = GetEventParameter(event, kEventParamTextInputSendText, textType,
+                        NULL, ret, NULL, theText);
+        if (myErr != noErr)
+        theRec->textsize = ret = 0;
+        *(theText + ret) = 0;
+
+    }
+    else if (theRec->text)
+        *(theRec->text) = 0;
+
+    if (TRACE_ON(mac_xim))
+    {
+        int i;
+
+        TRACE("text(%ld): ", ret);
+        for (i = 0; i < ret; i++)
+        {
+            MESSAGE("%02x", (unsigned char)*(theText + i));
+            MESSAGE("%s", (i % 2 == 0) ? "" : " ");
+        }
+        MESSAGE("\n");
+    }
+
+    return ret;
+}
+
+
+static void getTextRangeDesc(TSMHandle internals, EventRef event,  myAERecord *theRec)
+{
+    static TextRangeArray *theArray = NULL;
+    short           ret;
+    int             i;
+    TextRange      *theRange;
+    OSStatus        myErr;
+    Size            actualSize;
+
+    myErr = GetEventParameter(event, kEventParamTextInputSendHiliteRng,
+                typeTextRangeArray, NULL, 0, (UInt32*)&actualSize, NULL);
+    if (myErr == noErr)
+    {
+        if (theArray == NULL)
+        theArray = (TextRangeArray *)NewPtr(actualSize);
+        else if (actualSize > GetPtrSize((Ptr)theArray))
+        {
+            DisposePtr((Ptr)theArray);
+            theArray = (TextRangeArray *)NewPtr(actualSize);
+        }
+
+        myErr = GetEventParameter(event, kEventParamTextInputSendHiliteRng,
+                typeTextRangeArray, NULL, actualSize, NULL, theArray);
+        if (myErr != noErr)
+            return;
+
+        for (i = 0; i < theArray->fNumOfRanges; i++)
+        {
+            if (TRACE_ON(mac_xim))
+            {
+                TRACE("hilite(%d): ", theArray->fNumOfRanges);
+                MESSAGE("%s(%ld-%ld:%d)", i == 0 ? "" : ", ",
+                theArray->fRange[i].fStart, theArray->fRange[i].fEnd,
+                theArray->fRange[i].fHiliteStyle);
+                MESSAGE("\n");
+            }
+
+            if (theArray->fRange[i].fHiliteStyle == kTSMHiliteCaretPosition)
+                IME_SetCursorPos(internals->hIMC, theArray->fRange[i].fStart/2);
+        }
+
+        ret = theRec->hilitesize = theArray->fNumOfRanges;
+        if (ret == 0)
+            return;
+    }
+    else
+    {
+        if (theArray != NULL)
+            return;
+        myErr = GetEventParameter(event, kEventParamTextInputSendUpdateRng,
+                    typeTextRangeArray, NULL, 0, (UInt32*)&actualSize, NULL);
+        if (myErr != noErr)
+            return;
+        theArray = (TextRangeArray *)NewPtr(actualSize);
+        myErr = GetEventParameter(event, kEventParamTextInputSendUpdateRng,
+                    typeTextRangeArray, NULL, actualSize, NULL, theArray);
+        if (myErr != noErr)
+            return;
+        ret = theRec->hilitesize = theArray->fNumOfRanges;
+        if (ret != 2)
+            return;
+
+        if (TRACE_ON(mac_xim))
+        {
+            TRACE("update(%d): ", theRec->hilitesize);
+            for (i = 0; i < theRec->hilitesize; i++)
+                MESSAGE("%s(%ld-%ld)", i == 0 ? "" : ", ",
+                    theArray->fRange[i].fStart, theArray->fRange[i].fEnd);
+            MESSAGE("\n");
+        }
+
+        theArray->fRange[0].fStart = theArray->fRange[1].fStart;
+        theArray->fRange[0].fEnd = theArray->fRange[1].fEnd;
+        theArray->fRange[0].fHiliteStyle = 4;
+        theArray->fRange[1].fStart = theArray->fRange[1].fEnd;
+        theArray->fRange[1].fHiliteStyle = 1;
+    }
+
+    if (ret > theRec->hilitemax)
+    {
+        free(theRec->hiliteRange);
+        theRec->hiliteRange = (TextRange *) malloc(sizeof(TextRange) * ret);
+        theRec->hilitemax = ret;
+    }
+
+    theRange = theRec->hiliteRange;
+    for (i = 0; i < ret; i++)
+    {
+        (theRange + i)->fStart = theArray->fRange[i].fStart;
+        (theRange + i)->fEnd = theArray->fRange[i].fEnd;
+        (theRange + i)->fHiliteStyle = theArray->fRange[i].fHiliteStyle;
+    }
+}
+
+static OSStatus UpAcInputArea(EventRef event, TSMHandle internals)
+{
+    OSStatus        myErr;
+    long            fixLength;
+    long            textSize;
+    long            refCon;
+    myAERecord     *theRec;
+
+    theRec = &(internals->AERecord);
+
+    myErr = GetEventParameter(event, kEventParamTextInputSendRefCon,
+                typeLongInteger, NULL, sizeof(long), NULL, &refCon);
+
+    if (myErr == noErr)
+    {
+        textSize = getText(event,theRec);
+        TRACE("MacIM:AEUpdateEvent:textSize=%ld\n", textSize);
+    }
+
+    if (myErr != noErr)
+    {
+        return myErr;
+    }
+
+    myErr = GetEventParameter(event, kEventParamTextInputSendFixLen,
+                typeLongInteger, NULL, sizeof(long), NULL, &fixLength);
+    if (myErr == noErr)
+    {
+        theRec->fixsize = fixLength;
+        TRACE("HERE fix(%d)\n", theRec->fixsize);
+    }
+    else
+        return myErr;
+
+    if (textSize >= fixLength)
+        getTextRangeDesc(internals, event,theRec);
+
+    if (textSize > 0)
+    {
+        IME_SetCompositionString(internals->hIMC, theRec->text,textSize);
+
+        if (theRec->fixsize == textSize)
+            IME_NotifyComplete(internals->hIMC);
+    }
+    else
+        IME_SetCompositionString(internals->hIMC, NULL,0);
+
+    return noErr;
+}
+
+/* Apple Event Off2Pos */
+static OSStatus Off2P(EventRef event)
+{
+    OSStatus        myErr;
+    long            refCon;
+    BitMap          screenBits;
+    Point           pos = { 0, 0 };
+
+  /* extern void     getCurrTextPos(long, Point *); */
+
+    myErr = GetEventParameter(event, kEventParamTextInputSendRefCon,
+                typeLongInteger, NULL, sizeof(long), NULL, &refCon);
+
+/*
+    if (myErr == noErr)
+        getCurrTextPos(refCon, &pos);
+*/
+
+    if (pos.v == 0 && pos.h == 0)
+    {
+        GetQDGlobalsScreenBits(&screenBits);
+
+        pos.h = screenBits.bounds.right - kCandWindWidth - 4;
+        pos.v = screenBits.bounds.top + kMenuBarHeight + 4;
+    }
+
+    myErr = SetEventParameter(event, kEventParamTextInputReplyPoint,
+                    typeQDPoint, sizeof(Point), &pos);
+    return myErr;
+}
+
+static void UpdateCandWindow(TSMHandle internals)
+{
+    /*
+     * Mac Documentation says that this call is Deprecated
+     */
+    QDFlushPortBuffer(GetWindowPort(internals->CandWind), NULL);
+}
+
+static pascal OSStatus MacEventHandler(EventHandlerCallRef nextHandler,
+                    EventRef event, void *userData)
+{
+#pragma unused (nextHandler)
+
+    OSStatus        myErr, result = eventNotHandledErr;
+    UInt32          class, kind;
+    WindowRef       wind;
+    TSMHandle       internals = (TSMHandle)userData;
+
+    class = GetEventClass(event);
+    kind = GetEventKind(event);
+
+    TRACE("(%c%c%c%c:%ld)\n", (char)(class >> 24) & 0xff,
+        (char)(class >> 16) & 0xff, (char)(class >> 8) & 0xff,
+        (char)class & 0xff, kind);
+
+    switch (class)
+    {
+        case kEventClassTextInput:
+                switch (kind)
+                {
+                    case kEventTextInputUpdateActiveInputArea:
+                        TRACE("kEventTextInputUpdateActiveInputArea\n");
+                        if (internals->CandWind)
+                            UpdateCandWindow(internals);
+                        myErr = UpAcInputArea(event,internals);
+                        if (myErr == noErr)
+                            result = noErr;
+                        break;
+                    case kEventTextInputOffsetToPos:
+                        TRACE("kEventTextInputOffsetToPos\n");
+                        myErr = Off2P(event);
+                        if (myErr == noErr)
+                            result = noErr;
+                        break;
+                }
+                break;
+        case kEventClassWindow:
+            TRACE("kEventClassWindow\n");
+            myErr = GetEventParameter(event, kEventParamDirectObject,
+                        typeWindowRef, NULL, sizeof(WindowRef), NULL, &wind);
+            if (myErr != noErr)
+                break;
+            switch (kind)
+            {
+                case kEventWindowShown:
+                    TRACE("kEventWindowShown\n");
+                    if (internals->CandWind == NULL)
+                    {
+                        internals->CandWind = wind;
+                        UpdateCandWindow(internals);
+                    }
+                    break;
+                case kEventWindowHidden:
+                    TRACE("kEventWindowHidden\n");
+                    if (internals->CandWind == wind)
+                        internals->CandWind = NULL;
+                    break;
+            }
+            break;
+    }
+
+    return result;
+}
+
+long MacInstallAppEventHandler(TSMHandle internals)
+{
+    OSStatus        myErr;
+    EventTypeSpec   eventType[] = {
+            { kEventClassTextInput, kEventTextInputUpdateActiveInputArea },/*1*/
+            { kEventClassTextInput, kEventTextInputOffsetToPos },   /* 3 */
+            { kEventClassWindow, kEventWindowShown },   /* 24 */
+            { kEventClassWindow, kEventWindowHidden },  /* 25 */
+    };
+
+    TRACE("Setting up Event Handler\n");
+    myErr = InstallApplicationEventHandler(NewEventHandlerUPP(MacEventHandler),
+                GetEventTypeCount(eventType), eventType, internals,
+                &(internals->EventHandler));
+
+    if (myErr != noErr)
+    {
+        ERR("can't install app event handler (%ld)\n", myErr);
+        return myErr;
+    }
+
+    return noErr;
+}
+
+void MacRemoveAppEventHandler(TSMHandle internals)
+{
+    OSStatus        myErr;
+
+    myErr = RemoveEventHandler(internals->EventHandler);
+}
+
+void PumpEvents(void)
+{
+    EventRef theEvent;
+    EventTargetRef theTarget = NULL;
+    UInt32          class, kind;
+
+    if (theTarget == NULL)
+        theTarget = GetEventDispatcherTarget();
+
+    while (ReceiveNextEvent(0, NULL, 0.0001, TRUE, &theEvent) == noErr)
+    {
+    class = GetEventClass(theEvent);
+    kind = GetEventKind(theEvent);
+
+    TRACE("(%c%c%c%c:%ld)\n", (char)(class >> 24) & 0xff,
+        (char)(class >> 16) & 0xff, (char)(class >> 8) & 0xff,
+        (char)class & 0xff, kind);
+
+        SendEventToEventTarget(theEvent,theTarget);
+        ReleaseEvent(theEvent);
+    }
+}
+
+#endif /* __APPLE__ */
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/main.c wine-1.5.20/dlls/wineosxime.drv/main.c
--- wine-1.5.20-ori/dlls/wineosxime.drv/main.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/main.c	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,57 @@
+/*
+ * initialization code
+ *
+ * Copyright 2008 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include "windef.h"
+#include "winbase.h"
+#include "osxime_private.h"
+
+#include "wine/debug.h"
+WINE_DEFAULT_DEBUG_CHANNEL(mac_ime);
+
+#ifdef __APPLE__
+TSMHandle gHandle = NULL;
+#endif
+
+BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
+{
+#ifdef __APPLE__
+    BOOL ret = TRUE;
+
+    switch(reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(hinst);
+        IME_RegisterClasses(hinst);
+
+        if (!gHandle)
+            gHandle = Server_Init();
+        break;
+    case DLL_PROCESS_DETACH:
+        IME_UnregisterClasses(hinst);
+        Server_Shutdown();
+        break;
+    }
+    return ret;
+#else
+    return FALSE;
+#endif
+}
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/Makefile.in wine-1.5.20/dlls/wineosxime.drv/Makefile.in
--- wine-1.5.20-ori/dlls/wineosxime.drv/Makefile.in	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/Makefile.in	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,16 @@
+MODULE    = wineosxime.drv
+IMPORTS   = user32 gdi32 imm32 advapi32
+EXTRALIBS = @CARBONLIB@ @APPKITLIB@
+
+
+C_SRCS = \
+	ime.c \
+	keysym2ucs.c \
+	mactext.c \
+	main.c \
+	server.c \
+	toascii.c
+OBJC_SRCS = \
+    IMKClient.m
+
+@MAKE_DLL_RULES@
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/osxime_private.h wine-1.5.20/dlls/wineosxime.drv/osxime_private.h
--- wine-1.5.20-ori/dlls/wineosxime.drv/osxime_private.h	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/osxime_private.h	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2008 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef TSMHandle
+typedef void *TSMHandle;
+#endif
+
+/* mactext functions */
+
+int MacNewTSMDocument(TSMHandle handle, long refcon);
+int MacTSMEventCFS(TSMHandle handle, char theChar, unsigned long
+			theCode, unsigned long modifiers, unsigned long unichar, void* hIMC);
+TSMHandle MacInitTSMAwareApplication(void);
+void MacCloseTSMAwareApplication(TSMHandle handle);
+int MacTSMFixTextService(TSMHandle handle);
+int MacActivateTSMDocument(TSMHandle handle);
+int MacTSMRevertToPreviousMode(TSMHandle handle);
+int MacTSMCheckModeAndIME(TSMHandle handle);
+void MacRemoveAppEventHandler(TSMHandle handle);
+void MacInstallAppEventHandler(TSMHandle handle);
+
+/* toAscii */
+int XToAscii(UINT uVKey, UINT keysym, UINT keycode, CONST LPBYTE lpbKeyState,
+    LPDWORD lpdwTransKey, void* hIMC);
+int MacToAscii(UINT uVKey, WCHAR unichar, char theChar, unsigned long theCode, CONST LPBYTE lpbKeyState, LPDWORD lpdwTransKey, void* hIMC);
+
+/* IME support */
+void IME_RegisterClasses(HINSTANCE hImeInst);
+void IME_UnregisterClasses(HINSTANCE hImeInst);
+void IME_SetOpenStatus(BOOL fOpen);
+LRESULT IME_SendMessageToSelectedHWND(UINT msg, WPARAM wParam, LPARAM lParam);
+INT IME_GetCursorPos( void );
+void IME_UpdateAssociation(HWND focus);
+void IME_SetCompositionString(void* hIMC, LPCVOID lpComp, DWORD dwCompLen);
+BOOL IME_NotifyIME( void );
+
+/* MAC */
+void MAC_SetupXIM( void );
+
+/* Server */
+TSMHandle Server_Init(void);
+int Server_MacTSMCheckModeAndIME(void);
+void Server_MacTSMFixTextService(void);
+void Server_MacTSMRevertToPreviousMode(void);
+int Server_XToAscii(UINT uVKey, UINT keysym, UINT keycode, CONST LPBYTE lpbKeyState,
+    LPDWORD lpdwTransKey, void* hIMC);
+int Server_MacToAscii(UINT uVKey, WCHAR unichar, char theChar, unsigned long theCode, CONST LPBYTE lpbKeyState, LPDWORD lpdwTransKey, void* hIMC);
+
+void Server_Shutdown(void);
+void PumpEvents( void );
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/server.c wine-1.5.20/dlls/wineosxime.drv/server.c
--- wine-1.5.20-ori/dlls/wineosxime.drv/server.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/server.c	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,229 @@
+/*
+ * Copyright 2010 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "osxime_private.h"
+
+#include "wine/debug.h"
+WINE_DEFAULT_DEBUG_CHANNEL(mac_ime);
+
+enum FUNCTIONS {
+    MACTSMCHECKMODEANDIME,
+    MACTSMFIXTEXTSERVICE,
+    MACTSMREVERTTOPREVIOUSMODE,
+    XTOASCII,
+    MACTOASCII,
+    SHUTDOWN
+};
+
+typedef struct _serverPacket {
+    HANDLE      StartEvent;
+    HANDLE      EndEvent;
+    INT         requestedFunction;
+    INT         returnCode;
+    TSMHandle   TsmHandle;
+    HANDLE      threadHandle;
+    DWORD       threadId;
+
+    UINT uVKey;
+    UINT keysym;
+    UINT keycode;
+    LPBYTE lpbKeyState;
+    LPDWORD lpdwTransKey;
+    WCHAR unichar;
+    char theChar;
+    unsigned long theCode;
+    void* hIMC;
+} serverPacket;
+
+serverPacket packet;
+
+static CRITICAL_SECTION imeserver_cs;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &imeserver_cs,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": imeserver_cs") }
+};
+static CRITICAL_SECTION imeserver_cs = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static DWORD WINAPI ThreadMain(LPVOID param)
+{
+    BOOL exitNow = FALSE;
+    serverPacket *spacket = (serverPacket*)param;
+
+    MacInstallAppEventHandler(spacket->TsmHandle);
+    MacNewTSMDocument(spacket->TsmHandle,(long)0xfeedface);
+
+    SetEvent(spacket->EndEvent);
+    while (!exitNow)
+    {
+        WaitForSingleObject(spacket->StartEvent, INFINITE);
+
+        switch (spacket->requestedFunction)
+        {
+            case MACTSMCHECKMODEANDIME :
+                spacket->returnCode = MacTSMCheckModeAndIME(spacket->TsmHandle);
+                break;
+            case MACTSMFIXTEXTSERVICE:
+                MacTSMFixTextService(spacket->TsmHandle);
+                break;
+            case MACTSMREVERTTOPREVIOUSMODE:
+                MacTSMRevertToPreviousMode(spacket->TsmHandle);
+                break;
+            case XTOASCII:
+                spacket->returnCode = XToAscii(spacket->uVKey, spacket->keysym,
+spacket->keycode, spacket->lpbKeyState, spacket->lpdwTransKey, spacket->hIMC);
+                break;
+            case MACTOASCII:
+                spacket->returnCode = MacToAscii(spacket->uVKey, spacket->unichar,
+spacket->theChar, spacket->theCode, spacket->lpbKeyState, spacket->lpdwTransKey,
+            spacket->hIMC);
+                break;
+            case SHUTDOWN:
+                MacRemoveAppEventHandler(spacket->TsmHandle);
+                exitNow = TRUE;
+                break;
+            default:
+                ERR("Unknown function requested\n");
+        }
+        SetEvent(spacket->EndEvent);
+    }
+    return 0;
+}
+
+TSMHandle Server_Init(void)
+{
+    TRACE("->\n");
+    packet.threadHandle = NULL;
+    packet.TsmHandle = MacInitTSMAwareApplication();
+    TRACE("<-\n");
+    return packet.TsmHandle;
+}
+
+void Server_Shutdown(void)
+{
+    if (packet.threadHandle != NULL)
+    {
+        packet.requestedFunction = SHUTDOWN;
+        SetEvent(packet.StartEvent);
+        packet.threadHandle = NULL;
+    }
+    if (packet.TsmHandle)
+        MacCloseTSMAwareApplication(packet.TsmHandle);
+    TRACE("Server:End.\n");
+}
+
+static void WaitServer(void)
+{
+    SetEvent(packet.StartEvent);
+    WaitForSingleObject(packet.EndEvent, INFINITE);
+}
+
+static void CheckServer(void)
+{
+    if (!packet.threadHandle)
+    {
+        packet.StartEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+        packet.EndEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+        packet.threadHandle = CreateThread(NULL, 0, ThreadMain, &packet, 0, &packet.threadId);
+        WaitForSingleObject(packet.EndEvent, INFINITE);
+    }
+}
+
+int Server_MacTSMCheckModeAndIME(void)
+{
+    int rc;
+    TRACE("->\n");
+    EnterCriticalSection(&imeserver_cs);
+    CheckServer();
+    packet.requestedFunction = MACTSMCHECKMODEANDIME;
+    WaitServer();
+    rc = packet.returnCode;
+    LeaveCriticalSection(&imeserver_cs);
+    TRACE("<-\n");
+    return rc;
+}
+
+void Server_MacTSMFixTextService(void)
+{
+    TRACE("->\n");
+    EnterCriticalSection(&imeserver_cs);
+    CheckServer();
+    packet.requestedFunction = MACTSMFIXTEXTSERVICE;
+    WaitServer();
+    LeaveCriticalSection(&imeserver_cs);
+    TRACE("<-\n");
+}
+
+void Server_MacTSMRevertToPreviousMode(void)
+{
+    TRACE("->\n");
+    EnterCriticalSection(&imeserver_cs);
+    CheckServer();
+    packet.requestedFunction = MACTSMREVERTTOPREVIOUSMODE;
+    WaitServer();
+    LeaveCriticalSection(&imeserver_cs);
+    TRACE("<-\n");
+}
+
+
+int Server_XToAscii(UINT uVKey, UINT keysym, UINT keycode, CONST LPBYTE lpbKeyState,
+    LPDWORD lpdwTransKey, void* hIMC)
+{
+    int rc;
+    TRACE("->\n");
+    EnterCriticalSection(&imeserver_cs);
+    CheckServer();
+    packet.requestedFunction = XTOASCII;
+    packet.uVKey = uVKey;
+    packet.keysym = keysym;
+    packet.keycode = keycode;
+    packet.lpbKeyState = lpbKeyState;
+    packet.lpdwTransKey = lpdwTransKey;
+    packet.hIMC = hIMC;
+    WaitServer();
+    rc = packet.returnCode;
+    LeaveCriticalSection(&imeserver_cs);
+    TRACE("<-\n");
+    return rc;
+}
+
+int Server_MacToAscii(UINT uVKey, WCHAR unichar, char theChar, unsigned long theCode, CONST LPBYTE lpbKeyState, LPDWORD lpdwTransKey, void* hIMC)
+{
+    int rc;
+    TRACE("->\n");
+    EnterCriticalSection(&imeserver_cs);
+    CheckServer();
+    packet.requestedFunction = MACTOASCII;
+    packet.uVKey = uVKey;
+    packet.unichar = unichar;
+    packet.theChar = theChar;
+    packet.theCode = theCode;
+    packet.lpbKeyState = lpbKeyState;
+    packet.lpdwTransKey = lpdwTransKey;
+    packet.hIMC = hIMC;
+    WaitServer();
+    rc = packet.returnCode;
+    LeaveCriticalSection(&imeserver_cs);
+    TRACE("<-\n");
+    return rc;
+}
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/toascii.c wine-1.5.20/dlls/wineosxime.drv/toascii.c
--- wine-1.5.20-ori/dlls/wineosxime.drv/toascii.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/toascii.c	2012-12-28 15:09:57.000000000 +0800
@@ -0,0 +1,458 @@
+/*
+ * Functions to translate keys on the Mac intel OS X platform
+ *
+ * Copyright 2008 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#ifdef __APPLE__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+/* Wine Includes */
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "wingdi.h"
+#include "winnls.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "keysym2ucs.h"
+#include "wine/debug.h"
+
+#include "osxime_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mac_ime);
+
+/* These tables are from Events.h
+ * But i want to avoid bringing Mac headers into this file as it causes
+ * conflicts with the wine headers.
+ */
+enum {
+  kNullCharCode                 = 0,
+  kHomeCharCode                 = 1,
+  kEnterCharCode                = 3,
+  kEndCharCode                  = 4,
+  kHelpCharCode                 = 5,
+  kBellCharCode                 = 7,
+  kBackspaceCharCode            = 8,
+  kTabCharCode                  = 9,
+  kLineFeedCharCode             = 10,
+  kVerticalTabCharCode          = 11,
+  kPageUpCharCode               = 11,
+  kFormFeedCharCode             = 12,
+  kPageDownCharCode             = 12,
+  kReturnCharCode               = 13,
+  kFunctionKeyCharCode          = 16,
+  kCommandCharCode              = 17,   /* glyph available only in system fonts*/
+  kCheckCharCode                = 18,   /* glyph available only in system fonts*/
+  kDiamondCharCode              = 19,   /* glyph available only in system fonts*/
+  kAppleLogoCharCode            = 20,   /* glyph available only in system fonts*/
+  kEscapeCharCode               = 27,
+  kClearCharCode                = 27,
+  kLeftArrowCharCode            = 28,
+  kRightArrowCharCode           = 29,
+  kUpArrowCharCode              = 30,
+  kDownArrowCharCode            = 31,
+  kSpaceCharCode                = 32,
+  kDeleteCharCode               = 127,
+  kBulletCharCode               = 165,
+  kNonBreakingSpaceCharCode     = 202
+};
+
+enum {
+                                        /* modifiers */
+  activeFlagBit                 = 0,    /* activate? (activateEvt and mouseDown)*/
+  btnStateBit                   = 7,    /* state of button?*/
+  cmdKeyBit                     = 8,    /* command key down?*/
+  shiftKeyBit                   = 9,    /* shift key down?*/
+  alphaLockBit                  = 10,   /* alpha lock down?*/
+  optionKeyBit                  = 11,   /* option key down?*/
+  controlKeyBit                 = 12,   /* control key down?*/
+  rightShiftKeyBit              = 13,   /* right shift key down? Not supported on Mac OS X.*/
+  rightOptionKeyBit             = 14,   /* right Option key down? Not supported on Mac OS X.*/
+  rightControlKeyBit            = 15    /* right Control key down? Not supported on Mac OS X.*/
+};
+
+enum {
+  activeFlag                    = 1 << activeFlagBit,
+  btnState                      = 1 << btnStateBit,
+  cmdKey                        = 1 << cmdKeyBit,
+  shiftKey                      = 1 << shiftKeyBit,
+  alphaLock                     = 1 << alphaLockBit,
+  optionKey                     = 1 << optionKeyBit,
+  controlKey                    = 1 << controlKeyBit,
+  rightShiftKey                 = 1 << rightShiftKeyBit, /* Not supported on Mac OS X.*/
+  rightOptionKey                = 1 << rightOptionKeyBit, /* Not supported on Mac OS X.*/
+  rightControlKey               = 1 << rightControlKeyBit /* Not supported on Mac OS X.*/
+};
+
+/* End copy from Events.h */
+
+extern TSMHandle gHandle;
+
+#define XtoMacKeycode_KnownUnused -1
+
+int xToMacKeycodeMap[] = {
+    /*   0 -> */ XtoMacKeycode_KnownUnused,
+    /*   1 -> */  53,
+    /*   2 -> */  18,
+    /*   3 -> */  19,
+    /*   4 -> */  20,
+    /*   5 -> */  21,
+    /*   6 -> */  23,
+    /*   7 -> */  22,
+    /*   8 -> */  26,
+    /*   9 -> */  28,
+    /*  10 -> */  25,
+    /*  11 -> */  29,
+    /*  12 -> */  27,
+    /*  13 -> */  24,
+    /*  14 -> */  51,
+    /*  15 -> */  48,
+    /*  16 -> */  12,
+    /*  17 -> */  13,
+    /*  18 -> */  14,
+    /*  19 -> */  15,
+    /*  20 -> */  17,
+    /*  21 -> */  16,
+    /*  22 -> */  32,
+    /*  23 -> */  34,
+    /*  24 -> */  31,
+    /*  25 -> */  35,
+    /*  26 -> */  33,
+    /*  27 -> */  30,
+    /*  28 -> */  36,
+    /*  29 -> */  59,
+    /*  30 -> */   0,
+    /*  31 -> */   1,
+    /*  32 -> */   2,
+    /*  33 -> */   3,
+    /*  34 -> */   5,
+    /*  35 -> */   4,
+    /*  36 -> */  38,
+    /*  37 -> */  40,
+    /*  38 -> */  37,
+    /*  39 -> */  41,
+    /*  40 -> */  39,
+    /*  41 -> */  50,
+    /*  42 -> */  56,
+    /*  43 -> */  42,
+    /*  44 -> */   6,
+    /*  45 -> */   7,
+    /*  46 -> */   8,
+    /*  47 -> */   9,
+    /*  48 -> */  11,
+    /*  49 -> */  45,
+    /*  50 -> */  46,
+    /*  51 -> */  43,
+    /*  52 -> */  47,
+    /*  53 -> */  44,
+    /*  54 -> */  60,
+    /*  55 -> */  67,
+    /*  56 -> */  58,
+    /*  57 -> */  49,
+    /*  58 -> */  57,
+    /*  59 -> */ 122,
+    /*  60 -> */ 120,
+    /*  61 -> */  99,
+    /*  62 -> */ 118,
+    /*  63 -> */  96,
+    /*  64 -> */  97,
+    /*  65 -> */  98,
+    /*  66 -> */ 100,
+    /*  67 -> */ 101,
+    /*  68 -> */ 109,
+    /*  69 -> */  71,
+    /*  70 -> */ XtoMacKeycode_KnownUnused,
+    /*  71 -> */  89,
+    /*  72 -> */  91,
+    /*  73 -> */  92,
+    /*  74 -> */  78,
+    /*  75 -> */  86,
+    /*  76 -> */  87,
+    /*  77 -> */  88,
+    /*  78 -> */  69,
+    /*  79 -> */  83,
+    /*  80 -> */  84,
+    /*  81 -> */  85,
+    /*  82 -> */  82,
+    /*  83 -> */ XtoMacKeycode_KnownUnused,
+    /*  84 -> */ XtoMacKeycode_KnownUnused,
+    /*  85 -> */ XtoMacKeycode_KnownUnused,
+    /*  86 -> */  10,
+    /*  87 -> */ 103,
+    /*  88 -> */ 111,
+    /*  89 -> */ 115,
+    /*  90 -> */ 126,
+    /*  91 -> */ 116,
+    /*  92 -> */ 123,
+    /*  93 -> */ XtoMacKeycode_KnownUnused,
+    /*  94 -> */ 124,
+    /*  95 -> */ 119,
+    /*  96 -> */ 125,
+    /*  97 -> */ 121,
+    /*  98 -> */ 114,
+    /*  99 -> */ 117,
+    /* 100 -> */  76,
+    /* 101 -> */  62,
+    /* 102 -> */ XtoMacKeycode_KnownUnused,
+    /* 103 -> */ XtoMacKeycode_KnownUnused,
+    /* 104 -> */  75,
+    /* 105 -> */  61,
+    /* 106 -> */ XtoMacKeycode_KnownUnused,
+    /* 107 -> */  55,
+    /* 108 -> */  63,
+    /* 109 -> */ XtoMacKeycode_KnownUnused,
+    /* 110 -> */ 105, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: FK13.*/
+    /* 111 -> */ 107, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: FK14.*/
+    /* 112 -> */ 113, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: FK15.*/
+    /* 113 -> */ 106, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: FK16.*/
+    /* 114 -> */  64,
+    /* 115 -> */  65, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: KPDC.*/
+    /* 116 -> */  79,
+    /* 117 -> */  80,
+    /* 118 -> */  81,
+    /* 119 -> */  90,
+    /* 120 -> */ XtoMacKeycode_KnownUnused,
+    /* 121 -> */ 102, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: XFER.  This is a bit of a guess.  The Mac mappings do nothing but exit dead key states for JIS keyboards.  I'm assuming that's because they're about to switch states, which I'm guessing is what these keys do.*/
+    /* 122 -> */ XtoMacKeycode_KnownUnused,
+    /* 123 -> */ XtoMacKeycode_KnownUnused,
+    /* 124 -> */ XtoMacKeycode_KnownUnused,
+    /* 125 -> */  93, /* Only maps for JIS keyboards; maps to yen/pipe/backslash across many keyboard layouts.  From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: AE13.  That definition is labeled as "Yen".  Also, the position of the Yen key on JIS keyboards is to the right of AE12.*/
+    /* 126 -> */ XtoMacKeycode_KnownUnused,
+    /* 127 -> */ XtoMacKeycode_KnownUnused,
+    /* 128 -> */ XtoMacKeycode_KnownUnused,
+    /* 129 -> */ XtoMacKeycode_KnownUnused,
+    /* 130 -> */ XtoMacKeycode_KnownUnused,
+    /* 131 -> */ XtoMacKeycode_KnownUnused,
+    /* 132 -> */ XtoMacKeycode_KnownUnused,
+    /* 133 -> */ XtoMacKeycode_KnownUnused,
+    /* 134 -> */ XtoMacKeycode_KnownUnused,
+    /* 135 -> */ XtoMacKeycode_KnownUnused,
+    /* 136 -> */ XtoMacKeycode_KnownUnused,
+    /* 137 -> */ XtoMacKeycode_KnownUnused,
+    /* 138 -> */ XtoMacKeycode_KnownUnused,
+    /* 139 -> */ XtoMacKeycode_KnownUnused,
+    /* 140 -> */ XtoMacKeycode_KnownUnused,
+    /* 141 -> */ XtoMacKeycode_KnownUnused,
+    /* 142 -> */ XtoMacKeycode_KnownUnused,
+    /* 143 -> */ XtoMacKeycode_KnownUnused,
+    /* 144 -> */ XtoMacKeycode_KnownUnused,
+    /* 145 -> */ XtoMacKeycode_KnownUnused,
+    /* 146 -> */ XtoMacKeycode_KnownUnused,
+    /* 147 -> */ XtoMacKeycode_KnownUnused,
+    /* 148 -> */ XtoMacKeycode_KnownUnused,
+    /* 149 -> */ XtoMacKeycode_KnownUnused,
+    /* 150 -> */ XtoMacKeycode_KnownUnused,
+    /* 151 -> */ XtoMacKeycode_KnownUnused,
+    /* 152 -> */ XtoMacKeycode_KnownUnused,
+    /* 153 -> */ XtoMacKeycode_KnownUnused,
+    /* 154 -> */ XtoMacKeycode_KnownUnused,
+    /* 155 -> */ XtoMacKeycode_KnownUnused,
+    /* 156 -> */ XtoMacKeycode_KnownUnused,
+    /* 157 -> */ XtoMacKeycode_KnownUnused,
+    /* 158 -> */ XtoMacKeycode_KnownUnused,
+    /* 159 -> */ XtoMacKeycode_KnownUnused,
+    /* 160 -> */ XtoMacKeycode_KnownUnused,
+    /* 161 -> */ XtoMacKeycode_KnownUnused,
+    /* 162 -> */ XtoMacKeycode_KnownUnused,
+    /* 163 -> */ XtoMacKeycode_KnownUnused,
+    /* 164 -> */ XtoMacKeycode_KnownUnused,
+    /* 165 -> */ XtoMacKeycode_KnownUnused,
+    /* 166 -> */ XtoMacKeycode_KnownUnused,
+    /* 167 -> */ XtoMacKeycode_KnownUnused,
+    /* 168 -> */ XtoMacKeycode_KnownUnused,
+    /* 169 -> */ XtoMacKeycode_KnownUnused,
+    /* 170 -> */ XtoMacKeycode_KnownUnused,
+    /* 171 -> */ XtoMacKeycode_KnownUnused,
+    /* 172 -> */ XtoMacKeycode_KnownUnused,
+    /* 173 -> */ XtoMacKeycode_KnownUnused,
+    /* 174 -> */ XtoMacKeycode_KnownUnused,
+    /* 175 -> */ XtoMacKeycode_KnownUnused,
+    /* 176 -> */ XtoMacKeycode_KnownUnused,
+    /* 177 -> */ XtoMacKeycode_KnownUnused,
+    /* 178 -> */ XtoMacKeycode_KnownUnused,
+    /* 179 -> */ XtoMacKeycode_KnownUnused,
+    /* 180 -> */ XtoMacKeycode_KnownUnused,
+    /* 181 -> */ XtoMacKeycode_KnownUnused,
+    /* 182 -> */ XtoMacKeycode_KnownUnused,
+    /* 183 -> */ XtoMacKeycode_KnownUnused,
+    /* 184 -> */ XtoMacKeycode_KnownUnused,
+    /* 185 -> */ XtoMacKeycode_KnownUnused,
+    /* 186 -> */ XtoMacKeycode_KnownUnused,
+    /* 187 -> */ XtoMacKeycode_KnownUnused,
+    /* 188 -> */ XtoMacKeycode_KnownUnused,
+    /* 189 -> */ XtoMacKeycode_KnownUnused,
+    /* 190 -> */ XtoMacKeycode_KnownUnused,
+    /* 191 -> */ XtoMacKeycode_KnownUnused,
+    /* 192 -> */ XtoMacKeycode_KnownUnused,
+    /* 193 -> */ XtoMacKeycode_KnownUnused,
+    /* 194 -> */ XtoMacKeycode_KnownUnused,
+    /* 195 -> */ XtoMacKeycode_KnownUnused,
+    /* 196 -> */ XtoMacKeycode_KnownUnused,
+    /* 197 -> */ XtoMacKeycode_KnownUnused,
+    /* 198 -> */ XtoMacKeycode_KnownUnused,
+    /* 199 -> */ XtoMacKeycode_KnownUnused,
+    /* 200 -> */  104, /* From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: HKTG. In Leopard's Events.h, this keycode is documented as kVK_JIS_Kana, which I'm
+ assuming matches XKB's "Hiragana_Katakana toggle". */
+    /* 201 -> */ XtoMacKeycode_KnownUnused,
+    /* 202 -> */ XtoMacKeycode_KnownUnused,
+    /* 203 -> */  94, /* Only maps for JIS keyboards; maps to underscore/grave/combining-grave across many keyboard layouts.  From /usr/X11R6/lib/X11/xkb/keycodes/xfree86: AB11.  This is a bit of a guess.  That definition is labeled as "backslash/underscore".  Only the "underscore" part matches this key's mapping.*/
+    /* No X keycode maps to these Mac keycodes:
+       XXX ->     52, // This maps to the Enter character code in all keyboard layouts.  Is this some alternate Enter key?  See 76.
+       XXX ->     54,
+       XXX ->     66,
+       XXX ->     68,
+       XXX ->     70,
+       XXX ->     72,
+       XXX ->     73,
+       XXX ->     74,
+       XXX ->     77,
+       XXX ->     95, // Only maps for JIS keyboards; maps to comma for all modifier combinations across many keyboard layouts.  It seems unlikely that any such key exists.
+       XXX ->    108,
+       XXX ->    110,
+       XXX ->    112,
+       XXX ->    127,
+    */
+};
+
+int XToAscii(UINT uVKey, UINT keysym, UINT keycode, CONST LPBYTE lpbKeyState,
+    LPDWORD lpdwTransKey, void* hIMC)
+{
+	char theChar;
+    WCHAR unichar;
+	unsigned long theCode;
+	unsigned long modifiers;
+
+    modifiers = 0x00;
+
+/* modifiers  */
+
+  if (lpbKeyState[VK_SHIFT] & 0x80)
+    modifiers |= shiftKey;
+  if (lpbKeyState[VK_NUMLOCK] & 0x80)
+    modifiers |= alphaLock;
+  if (lpbKeyState[VK_CONTROL] & 0x80)
+    modifiers |= controlKey;
+  if (lpbKeyState[VK_MENU] & 0x80)
+    modifiers |= cmdKey;
+  if (lpbKeyState[VK_MENU] & 0x80)
+    modifiers |= optionKey;
+
+      switch(uVKey) {
+      case VK_LEFT:
+        theChar = kLeftArrowCharCode;
+        break;
+      case VK_UP:
+        theChar = kUpArrowCharCode;
+        break;
+      case VK_RIGHT:
+        theChar = kRightArrowCharCode;
+        break;
+      case VK_DOWN:
+        theChar = kDownArrowCharCode;
+        break;
+      case VK_DELETE:
+        theChar = kBackspaceCharCode;
+        break;
+      case VK_F1:
+      case VK_F2:
+      case VK_F3:
+      case VK_F4:
+      case VK_F5:
+      case VK_F6:
+      case VK_F7:
+      case VK_F8:
+      case VK_F9:
+      case VK_F10:
+      case VK_F11:
+      case VK_F12:
+        theChar = kFunctionKeyCharCode;
+        break;
+      default:
+        theChar = keysym & 0x00FF;
+        break;
+      }
+
+    theCode = keycode;//xToMacKeycodeMap[keycode];
+    MacActivateTSMDocument(gHandle);
+    unichar = keysym2ucs(keysym);
+
+    return MacTSMEventCFS(gHandle,theChar,theCode,modifiers,unichar,hIMC);
+}
+
+int MacToAscii(UINT uVKey, WCHAR unichar, char theChar, unsigned long theCode, CONST LPBYTE lpbKeyState, LPDWORD lpdwTransKey, void* hIMC)
+{
+	unsigned long modifiers;
+
+    modifiers = 0x00;
+
+/* modifiers  */
+
+  if (lpbKeyState[VK_SHIFT] & 0x80)
+    modifiers |= shiftKey;
+  if (lpbKeyState[VK_NUMLOCK] & 0x80)
+    modifiers |= alphaLock;
+  if (lpbKeyState[VK_CONTROL] & 0x80)
+    modifiers |= controlKey;
+  if (lpbKeyState[VK_MENU] & 0x80)
+    modifiers |= cmdKey;
+  if (lpbKeyState[VK_MENU] & 0x80)
+    modifiers |= optionKey;
+
+      switch(uVKey) {
+      case VK_LEFT:
+        theChar = kLeftArrowCharCode;
+        break;
+      case VK_UP:
+        theChar = kUpArrowCharCode;
+        break;
+      case VK_RIGHT:
+        theChar = kRightArrowCharCode;
+        break;
+      case VK_DOWN:
+        theChar = kDownArrowCharCode;
+        break;
+      case VK_DELETE:
+        theChar = kBackspaceCharCode;
+        break;
+      case VK_F1:
+      case VK_F2:
+      case VK_F3:
+      case VK_F4:
+      case VK_F5:
+      case VK_F6:
+      case VK_F7:
+      case VK_F8:
+      case VK_F9:
+      case VK_F10:
+      case VK_F11:
+      case VK_F12:
+        theChar = kFunctionKeyCharCode;
+        break;
+      default:
+        break;
+      }
+
+    MacActivateTSMDocument(gHandle);
+
+    return MacTSMEventCFS(gHandle,theChar,theCode,modifiers,unichar,hIMC);
+}
+#endif
diff -urN wine-1.5.20-ori/dlls/wineosxime.drv/wineosxime.drv.spec wine-1.5.20/dlls/wineosxime.drv/wineosxime.drv.spec
--- wine-1.5.20-ori/dlls/wineosxime.drv/wineosxime.drv.spec	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/wineosxime.drv/wineosxime.drv.spec	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,18 @@
+#ifdef __APPLE__
+@ stdcall ImeInquire(ptr wstr wstr)
+@ stdcall ImeConfigure(long long long ptr)
+@ stdcall ImeDestroy(long)
+@ stdcall ImeEscape(long long ptr)
+@ stdcall ImeSelect(long long)
+@ stdcall ImeSetActiveContext(long long)
+@ stdcall ImeToAsciiEx(long long ptr ptr long long)
+@ stdcall NotifyIME(long long long long)
+@ stdcall ImeRegisterWord(wstr long wstr)
+@ stdcall ImeUnregisterWord(wstr long wstr)
+@ stdcall ImeEnumRegisterWord(ptr wstr long wstr ptr)
+@ stdcall ImeSetCompositionString(long long ptr long ptr long)
+@ stdcall ImeConversionList(long wstr ptr long long)
+@ stdcall ImeProcessKey(long long long ptr)
+@ stdcall ImeGetRegisterWordStyle(wstr long wstr)
+@ stdcall ImeGetImeMenuItems(long long long ptr ptr long)
+#endif
diff -urN wine-1.5.20-ori/dlls/winex11.drv/keyboard.c wine-1.5.20/dlls/winex11.drv/keyboard.c
--- wine-1.5.20-ori/dlls/winex11.drv/keyboard.c	2012-12-22 03:14:42.000000000 +0800
+++ wine-1.5.20/dlls/winex11.drv/keyboard.c	2012-12-28 15:08:40.000000000 +0800
@@ -60,6 +60,10 @@
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
+#ifdef __APPLE__
+extern int ProcessMacInput(XKeyEvent*);
+#endif
+
 static int min_keycode, max_keycode, keysyms_per_keycode;
 static KeySym *key_mapping;
 static WORD keyc2vkey[256], keyc2scan[256];
@@ -1372,6 +1376,11 @@
     else
         ascii_chars = XLookupString(event, buf, sizeof(buf), &keysym, NULL);
 
+#ifdef __APPLE__
+	if (ProcessMacInput(event))
+		return;
+#endif
+
     TRACE_(key)("nbyte = %d, status %d\n", ascii_chars, status);
 
     if (status == XLookupChars)
diff -urN wine-1.5.20-ori/dlls/winex11.drv/mac_xim.c wine-1.5.20/dlls/winex11.drv/mac_xim.c
--- wine-1.5.20-ori/dlls/winex11.drv/mac_xim.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.5.20/dlls/winex11.drv/mac_xim.c	2012-12-28 15:08:40.000000000 +0800
@@ -0,0 +1,82 @@
+/*
+ * Functions for further XIM control on the Mac intel OS X platform
+ *
+ * Copyright 2006,2008 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#ifdef __APPLE__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+/* X includes */
+#include <X11/Xatom.h>
+#include <X11/keysym.h>
+#include <X11/Xlib.h>
+#include <X11/Xresource.h>
+#include <X11/Xutil.h>
+#ifdef HAVE_XKB
+#include <X11/XKBlib.h>
+#endif
+
+/* Wine Includes */
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "wingdi.h"
+#include "winnls.h"
+#include "imm.h"
+#include "ddk/imm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mac_ime);
+
+int ProcessMacInput(XKeyEvent *event)
+{
+    HWND wnd;
+    static HIMC hImc = NULL;
+    HIMC newImc = NULL;
+	KeySym keysym;
+
+	if (event->type != KeyPress)
+		return 0;
+
+    wnd = GetFocus();
+    newImc = ImmGetContext(wnd);
+
+    if (newImc != hImc)
+    {
+        hImc = newImc;
+        if (ImmGetIMEFileNameA(GetKeyboardLayout(0),NULL,0))
+        {
+            /* We have a non default IME  do not do our processing */
+            return 0;
+        }
+    }
+
+    if (hImc)
+    {
+	    XLookupString(event, NULL, 0, &keysym, NULL);
+        ImmEscapeW(GetKeyboardLayout(0),hImc,IME_ESC_PRIVATE_FIRST + 0x10, (LPVOID)keysym);
+        ImmEscapeW(GetKeyboardLayout(0),hImc,IME_ESC_PRIVATE_FIRST + 0x11, (LPVOID)(event->keycode-8));
+    }
+    return 0;
+}
+
+#endif /* __APPLE__ */
diff -urN wine-1.5.20-ori/dlls/winex11.drv/Makefile.in wine-1.5.20/dlls/winex11.drv/Makefile.in
--- wine-1.5.20-ori/dlls/winex11.drv/Makefile.in	2012-12-22 03:14:42.000000000 +0800
+++ wine-1.5.20/dlls/winex11.drv/Makefile.in	2012-12-28 15:08:40.000000000 +0800
@@ -14,6 +14,7 @@
 	ime.c \
 	init.c \
 	keyboard.c \
+	mac_xim.c \
 	mouse.c \
 	opengl.c \
 	palette.c \
diff -urN wine-1.5.20-ori/Make.rules.in wine-1.5.20/Make.rules.in
--- wine-1.5.20-ori/Make.rules.in	2012-12-22 03:14:42.000000000 +0800
+++ wine-1.5.20/Make.rules.in	2012-12-28 15:08:40.000000000 +0800
@@ -2,6 +2,7 @@
 #
 # Each individual makefile may define the following variables:
 # C_SRCS       : C sources for the module
+# OBJC_SRCS    : Objective-C sources for the module
 # RC_SRCS      : resource source files
 # EXTRA_SRCS   : extra source files for make depend
 # EXTRA_OBJS   : extra object files
@@ -29,7 +30,7 @@
                 $(BISON_SRCS:.y=.tab.c) $(BISON_SRCS:.y=.tab.h) $(LEX_SRCS:.l=.yy.c) \
                 $(PO_SRCS:%=rsrc.pot) $(MC_SRCS:%=msg.pot) $(XTEMPLATE_SRCS:.x=.h)
 
-OBJS = $(C_SRCS:.c=.o) $(BISON_SRCS:.y=.tab.o) $(LEX_SRCS:.l=.yy.o) $(IDL_GEN_C_SRCS:.c=.o) \
+OBJS = $(C_SRCS:.c=.o) @OBJC_OBJS@ $(BISON_SRCS:.y=.tab.o) $(LEX_SRCS:.l=.yy.o) $(IDL_GEN_C_SRCS:.c=.o) \
        $(IDL_R_SRCS:.idl=_r.res) $(IDL_TLB_RES) $(RC_SRCS:.rc=.res) $(MC_SRCS:.mc=.res) $(EXTRA_OBJS)
 
 CROSSOBJS = $(OBJS:.o=.cross.o)
@@ -42,11 +43,14 @@
 
 # Implicit rules
 
-.SUFFIXES: .mc .rc .res .idl .tlb .h .y .l .tab.c .tab.h .yy.c .ok .man.in .man _c.c _i.c _p.c _s.c _r.res _t.res .cross.o .po .mo @MAINTAINER_MODE@ .sfd .ttf .svg .ico .bmp
+.SUFFIXES: .mc .rc .res .idl .tlb .h .y .l .tab.c .tab.h .yy.c .ok .man.in .man _c.c _i.c _p.c _s.c _r.res _t.res .cross.o .po .mo .m @MAINTAINER_MODE@ .sfd .ttf .svg .ico .bmp
 
 .c.o:
 	$(CC) -c $(ALLCFLAGS) -o $@ $<
 
+.m.o:
+	$(CC) -c $(ALLCFLAGS) -o $@ $<
+
 .c.cross.o:
 	$(CROSSCC) -c $(INCLUDES) $(DEFS) -DWINE_CROSSTEST $(CPPFLAGS) $(CFLAGS) -o $@ $<
 
@@ -137,7 +141,7 @@
 
 # Rules for dependencies
 
-DEPEND_SRCS = $(C_SRCS) $(RC_SRCS) $(MC_SRCS) \
+DEPEND_SRCS = $(C_SRCS) @OBJC_SRCS@ $(RC_SRCS) $(MC_SRCS) \
               $(IDL_H_SRCS) $(IDL_C_SRCS) $(IDL_I_SRCS) $(IDL_P_SRCS) $(IDL_S_SRCS) \
               $(IDL_GEN_C_SRCS) $(IDL_R_SRCS:.idl=_r.res) $(IDL_TLB_SRCS) $(IDL_TLB_SRCS:.idl=.tlb) \
               $(BISON_SRCS) $(LEX_SRCS) $(EXTRA_SRCS)
